/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter add_pb_suffix,eslint_disable,ts_nocheck,keep_enum_prefix,long_type_number
// @generated from protobuf file "tdex-daemon/v1/types.proto" (package "tdex_daemon.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MarketWithFee } from "../../tdex/v1/types_pb";
import { Balance } from "../../tdex/v1/types_pb";
import { Price } from "../../tdex/v1/types_pb";
import { Fee } from "../../tdex/v1/types_pb";
import { Market } from "../../tdex/v1/types_pb";
/**
 * @generated from protobuf message tdex_daemon.v1.AccountInfo
 */
export interface AccountInfo {
    /**
     * The index of the wallet account.
     *
     * @generated from protobuf field: uint32 account_index = 1;
     */
    accountIndex: number;
    /**
     * The full derivation path.
     *
     * @generated from protobuf field: string derivation_path = 2;
     */
    derivationPath: string;
    /**
     * The master public key.
     *
     * @generated from protobuf field: string xpub = 3;
     */
    xpub: string;
    /**
     * The index of the last external address derived.
     *
     * @generated from protobuf field: uint32 last_external_derived = 4;
     */
    lastExternalDerived: number;
    /**
     * The index of the last internal address derived.
     *
     * @generated from protobuf field: uint32 last_internal_derived = 5;
     */
    lastInternalDerived: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.MarketInfo
 */
export interface MarketInfo {
    /**
     * The asset pair of the market
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The percentage and fixed fees
     *
     * @generated from protobuf field: tdex.v1.Fee fee = 2;
     */
    fee?: Fee;
    /**
     * Whether the market is opened or closed.
     *
     * @generated from protobuf field: bool tradable = 3;
     */
    tradable: boolean;
    /**
     * The making strategy.
     *
     * @generated from protobuf field: tdex_daemon.v1.StrategyType strategy_type = 4;
     */
    strategyType: StrategyType;
    /**
     * The index of the wallet account.
     *
     * @generated from protobuf field: uint64 account_index = 5;
     */
    accountIndex: number;
    /**
     * The current price in case the strategy is PLUGGABLE.
     *
     * @generated from protobuf field: tdex.v1.Price price = 6;
     */
    price?: Price;
    /**
     * The current unlocked balance.
     *
     * @generated from protobuf field: tdex.v1.Balance balance = 7;
     */
    balance?: Balance;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UtxoInfo
 */
export interface UtxoInfo {
    /**
     * The outpoint <hash, index>
     *
     * @generated from protobuf field: tdex_daemon.v1.Outpoint outpoint = 1;
     */
    outpoint?: Outpoint;
    /**
     * The unblinded value.
     *
     * @generated from protobuf field: uint64 value = 2;
     */
    value: number;
    /**
     * The unblinded asset.
     *
     * @generated from protobuf field: string asset = 3;
     */
    asset: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.TradeStatusInfo
 */
export interface TradeStatusInfo {
    /**
     * The status of the trade.
     *
     * @generated from protobuf field: tdex_daemon.v1.TradeStatus status = 1;
     */
    status: TradeStatus;
    /**
     * Whether it is failed in the current status.
     *
     * @generated from protobuf field: bool failed = 2;
     */
    failed: boolean;
}
/**
 * @generated from protobuf message tdex_daemon.v1.SwapInfo
 */
export interface SwapInfo {
    /**
     * The proposer's quantity.
     *
     * @generated from protobuf field: uint64 amount_p = 1;
     */
    amountP: number;
    /**
     * The proposer's asset hash.
     *
     * @generated from protobuf field: string asset_p = 2;
     */
    assetP: string;
    /**
     * The responder's quantity.
     *
     * @generated from protobuf field: uint64 amount_r = 3;
     */
    amountR: number;
    /**
     * The responder's asset hash.
     *
     * @generated from protobuf field: string asset_r = 4;
     */
    assetR: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.SwapFailInfo
 */
export interface SwapFailInfo {
    /**
     * The error code.
     *
     * @generated from protobuf field: uint32 failure_code = 1;
     */
    failureCode: number;
    /**
     * The error message.
     *
     * @generated from protobuf field: string failure_message = 2;
     */
    failureMessage: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.TradeInfo
 */
export interface TradeInfo {
    /**
     * The id of the trade.
     *
     * @generated from protobuf field: string trade_id = 1;
     */
    tradeId: string;
    /**
     * The info about the status of the trade.
     *
     * @generated from protobuf field: tdex_daemon.v1.TradeStatusInfo status = 2;
     */
    status?: TradeStatusInfo;
    /**
     * The info about the swap.
     *
     * @generated from protobuf field: tdex_daemon.v1.SwapInfo swap_info = 3;
     */
    swapInfo?: SwapInfo;
    /**
     * The info of an eventually failed swap.
     *
     * @generated from protobuf field: tdex_daemon.v1.SwapFailInfo fail_info = 4;
     */
    failInfo?: SwapFailInfo;
    /**
     * The collected fee on the current swap.
     *
     * @generated from protobuf field: tdex.v1.MarketWithFee market_with_fee = 5;
     */
    marketWithFee?: MarketWithFee;
    /**
     * The prices of the trade at request time.
     *
     * @generated from protobuf field: tdex_daemon.v1.TradePrice price = 6;
     */
    price?: TradePrice;
    /**
     * The eventual tx url with blinders in case the trade is settled.
     *
     * @generated from protobuf field: string tx_url = 7;
     */
    txUrl: string;
    /**
     * The unix timestamp of the SwapRequest.
     *
     * @generated from protobuf field: uint64 request_time_unix = 8;
     */
    requestTimeUnix: number;
    /**
     * The unix timestamp SwapAccept.
     *
     * @generated from protobuf field: uint64 accept_time_unix = 9;
     */
    acceptTimeUnix: number;
    /**
     * The unix timestamp of the SwapComplete.
     *
     * @generated from protobuf field: uint64 complete_time_unix = 10;
     */
    completeTimeUnix: number;
    /**
     * The unix timestamp of the settlement date.
     *
     * @generated from protobuf field: uint64 settle_time_unix = 11;
     */
    settleTimeUnix: number;
    /**
     * The unix timestamp of the expiration date.
     *
     * @generated from protobuf field: uint64 expiry_time_unix = 12;
     */
    expiryTimeUnix: number;
    /**
     * The UTC timestamp of the SwapRequest.
     *
     * @generated from protobuf field: string request_time_utc = 13;
     */
    requestTimeUtc: string;
    /**
     * The UTC timestamp of the SwapAccept.
     *
     * @generated from protobuf field: string accept_time_utc = 14;
     */
    acceptTimeUtc: string;
    /**
     * The UTC timestamp of the SwapComplete.
     *
     * @generated from protobuf field: string complete_time_utc = 15;
     */
    completeTimeUtc: string;
    /**
     * The UTC timestamp of the settlement date.
     *
     * @generated from protobuf field: string settle_time_utc = 16;
     */
    settleTimeUtc: string;
    /**
     * The UTC timestamp of the expiration date.
     *
     * @generated from protobuf field: string expiry_time_utc = 17;
     */
    expiryTimeUtc: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.FeeInfo
 */
export interface FeeInfo {
    /**
     * The id of the trade.
     *
     * @generated from protobuf field: string trade_id = 1;
     */
    tradeId: string;
    /**
     * The percentage fee applied to the trade.
     *
     * @generated from protobuf field: int64 basis_point = 2;
     */
    basisPoint: number;
    /**
     * The asset in which fees are collected.
     *
     * @generated from protobuf field: string asset = 3;
     */
    asset: string;
    /**
     * The amount in satoshi of the percentage fee.
     *
     * @generated from protobuf field: uint64 percentage_fee_amount = 4;
     */
    percentageFeeAmount: number;
    /**
     * The amount in satoshi of the fixed fee.
     *
     * @generated from protobuf field: uint64 fixed_fee_amount = 5;
     */
    fixedFeeAmount: number;
    /**
     * The market price when the trade propoal was accepted.
     *
     * @generated from protobuf field: float market_price = 6;
     */
    marketPrice: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.BalanceInfo
 */
export interface BalanceInfo {
    /**
     * The balance of the wallet
     *
     * @generated from protobuf field: uint64 total_balance = 1;
     */
    totalBalance: number;
    /**
     * The confirmed balance of a wallet(with >= 1 confirmations)
     *
     * @generated from protobuf field: uint64 confirmed_balance = 2;
     */
    confirmedBalance: number;
    /**
     * The unconfirmed balance of a wallet(with 0 confirmations)
     *
     * @generated from protobuf field: uint64 unconfirmed_balance = 3;
     */
    unconfirmedBalance: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.TxOutput
 */
export interface TxOutput {
    /**
     * The asset being spent
     *
     * @generated from protobuf field: string asset = 1;
     */
    asset: string;
    /**
     * The value of the output being spent.
     *
     * @generated from protobuf field: int64 value = 2;
     */
    value: number;
    /**
     * The confidential address of the output being spent.
     *
     * @generated from protobuf field: string address = 3;
     */
    address: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.AddressWithBlindingKey
 */
export interface AddressWithBlindingKey {
    /**
     * The confidential address encoded using a blech32 format.
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * The blinding private key for the given address encoded in hex format
     *
     * @generated from protobuf field: string blinding = 2;
     */
    blinding: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.Outpoint
 */
export interface Outpoint {
    /**
     * The hash of the transaction.
     *
     * @generated from protobuf field: string hash = 1;
     */
    hash: string;
    /**
     * The index of the output.
     *
     * @generated from protobuf field: int32 index = 2;
     */
    index: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.TradePrice
 */
export interface TradePrice {
    /**
     * @generated from protobuf field: double base_price = 1;
     */
    basePrice: number;
    /**
     * @generated from protobuf field: double quote_price = 2;
     */
    quotePrice: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WebhookInfo
 */
export interface WebhookInfo {
    /**
     * The id of the webhook.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The endpoint of the external service to reach.
     *
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * Whether the outgoing requests are authenticated.
     *
     * @generated from protobuf field: bool is_secured = 3;
     */
    isSecured: boolean;
    /**
     * The type of the action.
     *
     * @generated from protobuf field: tdex_daemon.v1.ActionType action_type = 4;
     */
    actionType: ActionType;
}
/**
 * @generated from protobuf message tdex_daemon.v1.Deposit
 */
export interface Deposit {
    /**
     * The utxo deposited.
     *
     * @generated from protobuf field: tdex_daemon.v1.UtxoInfo utxo = 1;
     */
    utxo?: UtxoInfo;
    /**
     * The timestamp of the deposit transaction in Unix format.
     *
     * @generated from protobuf field: uint64 timestamp_unix = 2;
     */
    timestampUnix: number;
    /**
     * The timestamp of the deposit transaction in UTC format.
     *
     * @generated from protobuf field: string timestamp_utc = 5;
     */
    timestampUtc: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.Withdrawal
 */
export interface Withdrawal {
    /**
     * The hash of the transaction included in mempool/blockchain.
     *
     * @generated from protobuf field: string tx_id = 1;
     */
    txId: string;
    /**
     * The balance withdrawn from the wallet account.
     *
     * @generated from protobuf field: tdex.v1.Balance balance = 2;
     */
    balance?: Balance;
    /**
     * The address where the funds have been sent.
     *
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * The timestamp of the withdrawal transaction in Unix format.
     *
     * @generated from protobuf field: uint64 timestamp_unix = 4;
     */
    timestampUnix: number;
    /**
     * The timestamp of the withdrawal transaction in UTC format.
     *
     * @generated from protobuf field: string timestamp_utc = 5;
     */
    timestampUtc: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.Page
 */
export interface Page {
    /**
     * The number of the page.
     *
     * @generated from protobuf field: int64 page_number = 1;
     */
    pageNumber: number;
    /**
     * The size of the page, ie the max length the returning list can have.
     *
     * @generated from protobuf field: int64 page_size = 2;
     */
    pageSize: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.MarketReport
 */
export interface MarketReport {
    /**
     * @generated from protobuf field: tdex_daemon.v1.MarketCollectedFees total_collected_fees = 1;
     */
    totalCollectedFees?: MarketCollectedFees;
    /**
     * @generated from protobuf field: tdex_daemon.v1.MarketVolume total_volume = 2;
     */
    totalVolume?: MarketVolume;
    /**
     * @generated from protobuf field: repeated tdex_daemon.v1.MarketVolume grouped_volume = 3;
     */
    groupedVolume: MarketVolume[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.MarketCollectedFees
 */
export interface MarketCollectedFees {
    /**
     * @generated from protobuf field: uint64 base_amount = 1;
     */
    baseAmount: number;
    /**
     * @generated from protobuf field: uint64 quote_amount = 2;
     */
    quoteAmount: number;
    /**
     * start_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string start_date = 3;
     */
    startDate: string;
    /**
     * end_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string end_date = 4;
     */
    endDate: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.MarketVolume
 */
export interface MarketVolume {
    /**
     * @generated from protobuf field: uint64 base_volume = 1;
     */
    baseVolume: number;
    /**
     * @generated from protobuf field: uint64 quote_volume = 2;
     */
    quoteVolume: number;
    /**
     * start_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string start_date = 3;
     */
    startDate: string;
    /**
     * end_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string end_date = 4;
     */
    endDate: string;
}
/**
 * TimeRange is flexible type used to determine time span for which specific
 * api will fetch data, either one of predefined_period or custom_period should be provided.
 *
 * @generated from protobuf message tdex_daemon.v1.TimeRange
 */
export interface TimeRange {
    /**
     * predefined time_period till now
     *
     * @generated from protobuf field: tdex_daemon.v1.PredefinedPeriod predefined_period = 1;
     */
    predefinedPeriod: PredefinedPeriod;
    /**
     * custom time range
     *
     * @generated from protobuf field: tdex_daemon.v1.CustomPeriod custom_period = 2;
     */
    customPeriod?: CustomPeriod;
}
/**
 * @generated from protobuf message tdex_daemon.v1.CustomPeriod
 */
export interface CustomPeriod {
    /**
     * start_date in RFC3339 format
     *
     * @generated from protobuf field: string start_date = 1;
     */
    startDate: string;
    /**
     * end_date in RFC3339 format
     *
     * @generated from protobuf field: string end_date = 2;
     */
    endDate: string;
}
/**
 * @generated from protobuf enum tdex_daemon.v1.StrategyType
 */
export enum StrategyType {
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_PLUGGABLE = 0;
     */
    STRATEGY_TYPE_PLUGGABLE = 0,
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_BALANCED = 1;
     */
    STRATEGY_TYPE_BALANCED = 1,
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_UNBALANCED = 2;
     */
    STRATEGY_TYPE_UNBALANCED = 2
}
/**
 * @generated from protobuf enum tdex_daemon.v1.TradeStatus
 */
export enum TradeStatus {
    /**
     * @generated from protobuf enum value: TRADE_STATUS_UNDEFINED = 0;
     */
    TRADE_STATUS_UNDEFINED = 0,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_REQUEST = 1;
     */
    TRADE_STATUS_REQUEST = 1,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_ACCEPT = 2;
     */
    TRADE_STATUS_ACCEPT = 2,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_COMPLETE = 3;
     */
    TRADE_STATUS_COMPLETE = 3,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_SETTLED = 4;
     */
    TRADE_STATUS_SETTLED = 4,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_EXPIRED = 5;
     */
    TRADE_STATUS_EXPIRED = 5
}
/**
 * @generated from protobuf enum tdex_daemon.v1.ActionType
 */
export enum ActionType {
    /**
     * @generated from protobuf enum value: ACTION_TYPE_TRADE_SETTLED = 0;
     */
    ACTION_TYPE_TRADE_SETTLED = 0,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_ACCOUNT_LOW_BALANCE = 1;
     */
    ACTION_TYPE_ACCOUNT_LOW_BALANCE = 1,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_ACCOUNT_WITHDRAW = 2;
     */
    ACTION_TYPE_ACCOUNT_WITHDRAW = 2,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_ALL_ACTIONS = 3;
     */
    ACTION_TYPE_ALL_ACTIONS = 3
}
/**
 * @generated from protobuf enum tdex_daemon.v1.PredefinedPeriod
 */
export enum PredefinedPeriod {
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_UNSPECIFIED = 0;
     */
    PREDEFINED_PERIOD_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_HOUR = 1;
     */
    PREDEFINED_PERIOD_LAST_HOUR = 1,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_DAY = 2;
     */
    PREDEFINED_PERIOD_LAST_DAY = 2,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_WEEK = 3;
     */
    PREDEFINED_PERIOD_LAST_WEEK = 3,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_MONTH = 4;
     */
    PREDEFINED_PERIOD_LAST_MONTH = 4,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_THREE_MONTHS = 5;
     */
    PREDEFINED_PERIOD_LAST_THREE_MONTHS = 5,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_YEAR_TO_DATE = 6;
     */
    PREDEFINED_PERIOD_YEAR_TO_DATE = 6,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_YEAR = 7;
     */
    PREDEFINED_PERIOD_LAST_YEAR = 7,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_ALL = 8;
     */
    PREDEFINED_PERIOD_ALL = 8
}
/**
 * @generated from protobuf enum tdex_daemon.v1.TimeFrame
 */
export enum TimeFrame {
    /**
     * @generated from protobuf enum value: TIME_FRAME_HOUR = 0;
     */
    TIME_FRAME_HOUR = 0,
    /**
     * @generated from protobuf enum value: TIME_FRAME_FOUR_HOURS = 1;
     */
    TIME_FRAME_FOUR_HOURS = 1,
    /**
     * @generated from protobuf enum value: TIME_FRAME_DAY = 2;
     */
    TIME_FRAME_DAY = 2,
    /**
     * @generated from protobuf enum value: TIME_FRAME_WEEK = 3;
     */
    TIME_FRAME_WEEK = 3,
    /**
     * @generated from protobuf enum value: TIME_FRAME_MONTH = 4;
     */
    TIME_FRAME_MONTH = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class AccountInfo$Type extends MessageType<AccountInfo> {
    constructor() {
        super("tdex_daemon.v1.AccountInfo", [
            { no: 1, name: "account_index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "derivation_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "xpub", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "last_external_derived", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "last_internal_derived", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<AccountInfo>): AccountInfo {
        const message = { accountIndex: 0, derivationPath: "", xpub: "", lastExternalDerived: 0, lastInternalDerived: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountInfo): AccountInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 account_index */ 1:
                    message.accountIndex = reader.uint32();
                    break;
                case /* string derivation_path */ 2:
                    message.derivationPath = reader.string();
                    break;
                case /* string xpub */ 3:
                    message.xpub = reader.string();
                    break;
                case /* uint32 last_external_derived */ 4:
                    message.lastExternalDerived = reader.uint32();
                    break;
                case /* uint32 last_internal_derived */ 5:
                    message.lastInternalDerived = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 account_index = 1; */
        if (message.accountIndex !== 0)
            writer.tag(1, WireType.Varint).uint32(message.accountIndex);
        /* string derivation_path = 2; */
        if (message.derivationPath !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.derivationPath);
        /* string xpub = 3; */
        if (message.xpub !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.xpub);
        /* uint32 last_external_derived = 4; */
        if (message.lastExternalDerived !== 0)
            writer.tag(4, WireType.Varint).uint32(message.lastExternalDerived);
        /* uint32 last_internal_derived = 5; */
        if (message.lastInternalDerived !== 0)
            writer.tag(5, WireType.Varint).uint32(message.lastInternalDerived);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.AccountInfo
 */
export const AccountInfo = new AccountInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketInfo$Type extends MessageType<MarketInfo> {
    constructor() {
        super("tdex_daemon.v1.MarketInfo", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "fee", kind: "message", T: () => Fee },
            { no: 3, name: "tradable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "strategy_type", kind: "enum", T: () => ["tdex_daemon.v1.StrategyType", StrategyType] },
            { no: 5, name: "account_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "price", kind: "message", T: () => Price },
            { no: 7, name: "balance", kind: "message", T: () => Balance }
        ]);
    }
    create(value?: PartialMessage<MarketInfo>): MarketInfo {
        const message = { tradable: false, strategyType: 0, accountIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketInfo): MarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Fee fee */ 2:
                    message.fee = Fee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* bool tradable */ 3:
                    message.tradable = reader.bool();
                    break;
                case /* tdex_daemon.v1.StrategyType strategy_type */ 4:
                    message.strategyType = reader.int32();
                    break;
                case /* uint64 account_index */ 5:
                    message.accountIndex = reader.uint64().toNumber();
                    break;
                case /* tdex.v1.Price price */ 6:
                    message.price = Price.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tdex.v1.Balance balance */ 7:
                    message.balance = Balance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Fee fee = 2; */
        if (message.fee)
            Fee.internalBinaryWrite(message.fee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool tradable = 3; */
        if (message.tradable !== false)
            writer.tag(3, WireType.Varint).bool(message.tradable);
        /* tdex_daemon.v1.StrategyType strategy_type = 4; */
        if (message.strategyType !== 0)
            writer.tag(4, WireType.Varint).int32(message.strategyType);
        /* uint64 account_index = 5; */
        if (message.accountIndex !== 0)
            writer.tag(5, WireType.Varint).uint64(message.accountIndex);
        /* tdex.v1.Price price = 6; */
        if (message.price)
            Price.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Balance balance = 7; */
        if (message.balance)
            Balance.internalBinaryWrite(message.balance, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.MarketInfo
 */
export const MarketInfo = new MarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UtxoInfo$Type extends MessageType<UtxoInfo> {
    constructor() {
        super("tdex_daemon.v1.UtxoInfo", [
            { no: 1, name: "outpoint", kind: "message", T: () => Outpoint },
            { no: 2, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UtxoInfo>): UtxoInfo {
        const message = { value: 0, asset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UtxoInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UtxoInfo): UtxoInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.Outpoint outpoint */ 1:
                    message.outpoint = Outpoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* uint64 value */ 2:
                    message.value = reader.uint64().toNumber();
                    break;
                case /* string asset */ 3:
                    message.asset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UtxoInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.Outpoint outpoint = 1; */
        if (message.outpoint)
            Outpoint.internalBinaryWrite(message.outpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).uint64(message.value);
        /* string asset = 3; */
        if (message.asset !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.asset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UtxoInfo
 */
export const UtxoInfo = new UtxoInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeStatusInfo$Type extends MessageType<TradeStatusInfo> {
    constructor() {
        super("tdex_daemon.v1.TradeStatusInfo", [
            { no: 1, name: "status", kind: "enum", T: () => ["tdex_daemon.v1.TradeStatus", TradeStatus] },
            { no: 2, name: "failed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TradeStatusInfo>): TradeStatusInfo {
        const message = { status: 0, failed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradeStatusInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeStatusInfo): TradeStatusInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.TradeStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* bool failed */ 2:
                    message.failed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeStatusInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.TradeStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* bool failed = 2; */
        if (message.failed !== false)
            writer.tag(2, WireType.Varint).bool(message.failed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.TradeStatusInfo
 */
export const TradeStatusInfo = new TradeStatusInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapInfo$Type extends MessageType<SwapInfo> {
    constructor() {
        super("tdex_daemon.v1.SwapInfo", [
            { no: 1, name: "amount_p", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "asset_p", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount_r", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "asset_r", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SwapInfo>): SwapInfo {
        const message = { amountP: 0, assetP: "", amountR: 0, assetR: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwapInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapInfo): SwapInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 amount_p */ 1:
                    message.amountP = reader.uint64().toNumber();
                    break;
                case /* string asset_p */ 2:
                    message.assetP = reader.string();
                    break;
                case /* uint64 amount_r */ 3:
                    message.amountR = reader.uint64().toNumber();
                    break;
                case /* string asset_r */ 4:
                    message.assetR = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 amount_p = 1; */
        if (message.amountP !== 0)
            writer.tag(1, WireType.Varint).uint64(message.amountP);
        /* string asset_p = 2; */
        if (message.assetP !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.assetP);
        /* uint64 amount_r = 3; */
        if (message.amountR !== 0)
            writer.tag(3, WireType.Varint).uint64(message.amountR);
        /* string asset_r = 4; */
        if (message.assetR !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.assetR);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.SwapInfo
 */
export const SwapInfo = new SwapInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapFailInfo$Type extends MessageType<SwapFailInfo> {
    constructor() {
        super("tdex_daemon.v1.SwapFailInfo", [
            { no: 1, name: "failure_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "failure_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SwapFailInfo>): SwapFailInfo {
        const message = { failureCode: 0, failureMessage: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwapFailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapFailInfo): SwapFailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 failure_code */ 1:
                    message.failureCode = reader.uint32();
                    break;
                case /* string failure_message */ 2:
                    message.failureMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapFailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 failure_code = 1; */
        if (message.failureCode !== 0)
            writer.tag(1, WireType.Varint).uint32(message.failureCode);
        /* string failure_message = 2; */
        if (message.failureMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.failureMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.SwapFailInfo
 */
export const SwapFailInfo = new SwapFailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeInfo$Type extends MessageType<TradeInfo> {
    constructor() {
        super("tdex_daemon.v1.TradeInfo", [
            { no: 1, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "message", T: () => TradeStatusInfo },
            { no: 3, name: "swap_info", kind: "message", T: () => SwapInfo },
            { no: 4, name: "fail_info", kind: "message", T: () => SwapFailInfo },
            { no: 5, name: "market_with_fee", kind: "message", T: () => MarketWithFee },
            { no: 6, name: "price", kind: "message", T: () => TradePrice },
            { no: 7, name: "tx_url", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "request_time_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 9, name: "accept_time_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 10, name: "complete_time_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 11, name: "settle_time_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 12, name: "expiry_time_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 13, name: "request_time_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "accept_time_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "complete_time_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "settle_time_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 17, name: "expiry_time_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradeInfo>): TradeInfo {
        const message = { tradeId: "", txUrl: "", requestTimeUnix: 0, acceptTimeUnix: 0, completeTimeUnix: 0, settleTimeUnix: 0, expiryTimeUnix: 0, requestTimeUtc: "", acceptTimeUtc: "", completeTimeUtc: "", settleTimeUtc: "", expiryTimeUtc: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeInfo): TradeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_id */ 1:
                    message.tradeId = reader.string();
                    break;
                case /* tdex_daemon.v1.TradeStatusInfo status */ 2:
                    message.status = TradeStatusInfo.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* tdex_daemon.v1.SwapInfo swap_info */ 3:
                    message.swapInfo = SwapInfo.internalBinaryRead(reader, reader.uint32(), options, message.swapInfo);
                    break;
                case /* tdex_daemon.v1.SwapFailInfo fail_info */ 4:
                    message.failInfo = SwapFailInfo.internalBinaryRead(reader, reader.uint32(), options, message.failInfo);
                    break;
                case /* tdex.v1.MarketWithFee market_with_fee */ 5:
                    message.marketWithFee = MarketWithFee.internalBinaryRead(reader, reader.uint32(), options, message.marketWithFee);
                    break;
                case /* tdex_daemon.v1.TradePrice price */ 6:
                    message.price = TradePrice.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* string tx_url */ 7:
                    message.txUrl = reader.string();
                    break;
                case /* uint64 request_time_unix */ 8:
                    message.requestTimeUnix = reader.uint64().toNumber();
                    break;
                case /* uint64 accept_time_unix */ 9:
                    message.acceptTimeUnix = reader.uint64().toNumber();
                    break;
                case /* uint64 complete_time_unix */ 10:
                    message.completeTimeUnix = reader.uint64().toNumber();
                    break;
                case /* uint64 settle_time_unix */ 11:
                    message.settleTimeUnix = reader.uint64().toNumber();
                    break;
                case /* uint64 expiry_time_unix */ 12:
                    message.expiryTimeUnix = reader.uint64().toNumber();
                    break;
                case /* string request_time_utc */ 13:
                    message.requestTimeUtc = reader.string();
                    break;
                case /* string accept_time_utc */ 14:
                    message.acceptTimeUtc = reader.string();
                    break;
                case /* string complete_time_utc */ 15:
                    message.completeTimeUtc = reader.string();
                    break;
                case /* string settle_time_utc */ 16:
                    message.settleTimeUtc = reader.string();
                    break;
                case /* string expiry_time_utc */ 17:
                    message.expiryTimeUtc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_id = 1; */
        if (message.tradeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeId);
        /* tdex_daemon.v1.TradeStatusInfo status = 2; */
        if (message.status)
            TradeStatusInfo.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.SwapInfo swap_info = 3; */
        if (message.swapInfo)
            SwapInfo.internalBinaryWrite(message.swapInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.SwapFailInfo fail_info = 4; */
        if (message.failInfo)
            SwapFailInfo.internalBinaryWrite(message.failInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.MarketWithFee market_with_fee = 5; */
        if (message.marketWithFee)
            MarketWithFee.internalBinaryWrite(message.marketWithFee, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.TradePrice price = 6; */
        if (message.price)
            TradePrice.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* string tx_url = 7; */
        if (message.txUrl !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.txUrl);
        /* uint64 request_time_unix = 8; */
        if (message.requestTimeUnix !== 0)
            writer.tag(8, WireType.Varint).uint64(message.requestTimeUnix);
        /* uint64 accept_time_unix = 9; */
        if (message.acceptTimeUnix !== 0)
            writer.tag(9, WireType.Varint).uint64(message.acceptTimeUnix);
        /* uint64 complete_time_unix = 10; */
        if (message.completeTimeUnix !== 0)
            writer.tag(10, WireType.Varint).uint64(message.completeTimeUnix);
        /* uint64 settle_time_unix = 11; */
        if (message.settleTimeUnix !== 0)
            writer.tag(11, WireType.Varint).uint64(message.settleTimeUnix);
        /* uint64 expiry_time_unix = 12; */
        if (message.expiryTimeUnix !== 0)
            writer.tag(12, WireType.Varint).uint64(message.expiryTimeUnix);
        /* string request_time_utc = 13; */
        if (message.requestTimeUtc !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.requestTimeUtc);
        /* string accept_time_utc = 14; */
        if (message.acceptTimeUtc !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.acceptTimeUtc);
        /* string complete_time_utc = 15; */
        if (message.completeTimeUtc !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.completeTimeUtc);
        /* string settle_time_utc = 16; */
        if (message.settleTimeUtc !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.settleTimeUtc);
        /* string expiry_time_utc = 17; */
        if (message.expiryTimeUtc !== "")
            writer.tag(17, WireType.LengthDelimited).string(message.expiryTimeUtc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.TradeInfo
 */
export const TradeInfo = new TradeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeInfo$Type extends MessageType<FeeInfo> {
    constructor() {
        super("tdex_daemon.v1.FeeInfo", [
            { no: 1, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "basis_point", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "percentage_fee_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "fixed_fee_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "market_price", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FeeInfo>): FeeInfo {
        const message = { tradeId: "", basisPoint: 0, asset: "", percentageFeeAmount: 0, fixedFeeAmount: 0, marketPrice: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeInfo): FeeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_id */ 1:
                    message.tradeId = reader.string();
                    break;
                case /* int64 basis_point */ 2:
                    message.basisPoint = reader.int64().toNumber();
                    break;
                case /* string asset */ 3:
                    message.asset = reader.string();
                    break;
                case /* uint64 percentage_fee_amount */ 4:
                    message.percentageFeeAmount = reader.uint64().toNumber();
                    break;
                case /* uint64 fixed_fee_amount */ 5:
                    message.fixedFeeAmount = reader.uint64().toNumber();
                    break;
                case /* float market_price */ 6:
                    message.marketPrice = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_id = 1; */
        if (message.tradeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeId);
        /* int64 basis_point = 2; */
        if (message.basisPoint !== 0)
            writer.tag(2, WireType.Varint).int64(message.basisPoint);
        /* string asset = 3; */
        if (message.asset !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.asset);
        /* uint64 percentage_fee_amount = 4; */
        if (message.percentageFeeAmount !== 0)
            writer.tag(4, WireType.Varint).uint64(message.percentageFeeAmount);
        /* uint64 fixed_fee_amount = 5; */
        if (message.fixedFeeAmount !== 0)
            writer.tag(5, WireType.Varint).uint64(message.fixedFeeAmount);
        /* float market_price = 6; */
        if (message.marketPrice !== 0)
            writer.tag(6, WireType.Bit32).float(message.marketPrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.FeeInfo
 */
export const FeeInfo = new FeeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BalanceInfo$Type extends MessageType<BalanceInfo> {
    constructor() {
        super("tdex_daemon.v1.BalanceInfo", [
            { no: 1, name: "total_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "confirmed_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "unconfirmed_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<BalanceInfo>): BalanceInfo {
        const message = { totalBalance: 0, confirmedBalance: 0, unconfirmedBalance: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BalanceInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BalanceInfo): BalanceInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 total_balance */ 1:
                    message.totalBalance = reader.uint64().toNumber();
                    break;
                case /* uint64 confirmed_balance */ 2:
                    message.confirmedBalance = reader.uint64().toNumber();
                    break;
                case /* uint64 unconfirmed_balance */ 3:
                    message.unconfirmedBalance = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BalanceInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 total_balance = 1; */
        if (message.totalBalance !== 0)
            writer.tag(1, WireType.Varint).uint64(message.totalBalance);
        /* uint64 confirmed_balance = 2; */
        if (message.confirmedBalance !== 0)
            writer.tag(2, WireType.Varint).uint64(message.confirmedBalance);
        /* uint64 unconfirmed_balance = 3; */
        if (message.unconfirmedBalance !== 0)
            writer.tag(3, WireType.Varint).uint64(message.unconfirmedBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.BalanceInfo
 */
export const BalanceInfo = new BalanceInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxOutput$Type extends MessageType<TxOutput> {
    constructor() {
        super("tdex_daemon.v1.TxOutput", [
            { no: 1, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TxOutput>): TxOutput {
        const message = { asset: "", value: 0, address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxOutput): TxOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string asset */ 1:
                    message.asset = reader.string();
                    break;
                case /* int64 value */ 2:
                    message.value = reader.int64().toNumber();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string asset = 1; */
        if (message.asset !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.asset);
        /* int64 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int64(message.value);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.TxOutput
 */
export const TxOutput = new TxOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddressWithBlindingKey$Type extends MessageType<AddressWithBlindingKey> {
    constructor() {
        super("tdex_daemon.v1.AddressWithBlindingKey", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blinding", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddressWithBlindingKey>): AddressWithBlindingKey {
        const message = { address: "", blinding: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddressWithBlindingKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddressWithBlindingKey): AddressWithBlindingKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string blinding */ 2:
                    message.blinding = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddressWithBlindingKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string blinding = 2; */
        if (message.blinding !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.blinding);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.AddressWithBlindingKey
 */
export const AddressWithBlindingKey = new AddressWithBlindingKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Outpoint$Type extends MessageType<Outpoint> {
    constructor() {
        super("tdex_daemon.v1.Outpoint", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "index", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Outpoint>): Outpoint {
        const message = { hash: "", index: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Outpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Outpoint): Outpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                case /* int32 index */ 2:
                    message.index = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Outpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        /* int32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).int32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.Outpoint
 */
export const Outpoint = new Outpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradePrice$Type extends MessageType<TradePrice> {
    constructor() {
        super("tdex_daemon.v1.TradePrice", [
            { no: 1, name: "base_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "quote_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TradePrice>): TradePrice {
        const message = { basePrice: 0, quotePrice: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradePrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradePrice): TradePrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double base_price */ 1:
                    message.basePrice = reader.double();
                    break;
                case /* double quote_price */ 2:
                    message.quotePrice = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradePrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double base_price = 1; */
        if (message.basePrice !== 0)
            writer.tag(1, WireType.Bit64).double(message.basePrice);
        /* double quote_price = 2; */
        if (message.quotePrice !== 0)
            writer.tag(2, WireType.Bit64).double(message.quotePrice);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.TradePrice
 */
export const TradePrice = new TradePrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebhookInfo$Type extends MessageType<WebhookInfo> {
    constructor() {
        super("tdex_daemon.v1.WebhookInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_secured", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "action_type", kind: "enum", T: () => ["tdex_daemon.v1.ActionType", ActionType] }
        ]);
    }
    create(value?: PartialMessage<WebhookInfo>): WebhookInfo {
        const message = { id: "", endpoint: "", isSecured: false, actionType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WebhookInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebhookInfo): WebhookInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* bool is_secured */ 3:
                    message.isSecured = reader.bool();
                    break;
                case /* tdex_daemon.v1.ActionType action_type */ 4:
                    message.actionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebhookInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* bool is_secured = 3; */
        if (message.isSecured !== false)
            writer.tag(3, WireType.Varint).bool(message.isSecured);
        /* tdex_daemon.v1.ActionType action_type = 4; */
        if (message.actionType !== 0)
            writer.tag(4, WireType.Varint).int32(message.actionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WebhookInfo
 */
export const WebhookInfo = new WebhookInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Deposit$Type extends MessageType<Deposit> {
    constructor() {
        super("tdex_daemon.v1.Deposit", [
            { no: 1, name: "utxo", kind: "message", T: () => UtxoInfo },
            { no: 2, name: "timestamp_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "timestamp_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Deposit>): Deposit {
        const message = { timestampUnix: 0, timestampUtc: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Deposit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Deposit): Deposit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.UtxoInfo utxo */ 1:
                    message.utxo = UtxoInfo.internalBinaryRead(reader, reader.uint32(), options, message.utxo);
                    break;
                case /* uint64 timestamp_unix */ 2:
                    message.timestampUnix = reader.uint64().toNumber();
                    break;
                case /* string timestamp_utc */ 5:
                    message.timestampUtc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Deposit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.UtxoInfo utxo = 1; */
        if (message.utxo)
            UtxoInfo.internalBinaryWrite(message.utxo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 timestamp_unix = 2; */
        if (message.timestampUnix !== 0)
            writer.tag(2, WireType.Varint).uint64(message.timestampUnix);
        /* string timestamp_utc = 5; */
        if (message.timestampUtc !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.timestampUtc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.Deposit
 */
export const Deposit = new Deposit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Withdrawal$Type extends MessageType<Withdrawal> {
    constructor() {
        super("tdex_daemon.v1.Withdrawal", [
            { no: 1, name: "tx_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "balance", kind: "message", T: () => Balance },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp_unix", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "timestamp_utc", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Withdrawal>): Withdrawal {
        const message = { txId: "", address: "", timestampUnix: 0, timestampUtc: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Withdrawal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Withdrawal): Withdrawal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string tx_id */ 1:
                    message.txId = reader.string();
                    break;
                case /* tdex.v1.Balance balance */ 2:
                    message.balance = Balance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* uint64 timestamp_unix */ 4:
                    message.timestampUnix = reader.uint64().toNumber();
                    break;
                case /* string timestamp_utc */ 5:
                    message.timestampUtc = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Withdrawal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string tx_id = 1; */
        if (message.txId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txId);
        /* tdex.v1.Balance balance = 2; */
        if (message.balance)
            Balance.internalBinaryWrite(message.balance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* uint64 timestamp_unix = 4; */
        if (message.timestampUnix !== 0)
            writer.tag(4, WireType.Varint).uint64(message.timestampUnix);
        /* string timestamp_utc = 5; */
        if (message.timestampUtc !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.timestampUtc);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.Withdrawal
 */
export const Withdrawal = new Withdrawal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Page$Type extends MessageType<Page> {
    constructor() {
        super("tdex_daemon.v1.Page", [
            { no: 1, name: "page_number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "page_size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<Page>): Page {
        const message = { pageNumber: 0, pageSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Page>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Page): Page {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 page_number */ 1:
                    message.pageNumber = reader.int64().toNumber();
                    break;
                case /* int64 page_size */ 2:
                    message.pageSize = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Page, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 page_number = 1; */
        if (message.pageNumber !== 0)
            writer.tag(1, WireType.Varint).int64(message.pageNumber);
        /* int64 page_size = 2; */
        if (message.pageSize !== 0)
            writer.tag(2, WireType.Varint).int64(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.Page
 */
export const Page = new Page$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketReport$Type extends MessageType<MarketReport> {
    constructor() {
        super("tdex_daemon.v1.MarketReport", [
            { no: 1, name: "total_collected_fees", kind: "message", T: () => MarketCollectedFees },
            { no: 2, name: "total_volume", kind: "message", T: () => MarketVolume },
            { no: 3, name: "grouped_volume", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<MarketReport>): MarketReport {
        const message = { groupedVolume: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketReport): MarketReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.MarketCollectedFees total_collected_fees */ 1:
                    message.totalCollectedFees = MarketCollectedFees.internalBinaryRead(reader, reader.uint32(), options, message.totalCollectedFees);
                    break;
                case /* tdex_daemon.v1.MarketVolume total_volume */ 2:
                    message.totalVolume = MarketVolume.internalBinaryRead(reader, reader.uint32(), options, message.totalVolume);
                    break;
                case /* repeated tdex_daemon.v1.MarketVolume grouped_volume */ 3:
                    message.groupedVolume.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.MarketCollectedFees total_collected_fees = 1; */
        if (message.totalCollectedFees)
            MarketCollectedFees.internalBinaryWrite(message.totalCollectedFees, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.MarketVolume total_volume = 2; */
        if (message.totalVolume)
            MarketVolume.internalBinaryWrite(message.totalVolume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v1.MarketVolume grouped_volume = 3; */
        for (let i = 0; i < message.groupedVolume.length; i++)
            MarketVolume.internalBinaryWrite(message.groupedVolume[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.MarketReport
 */
export const MarketReport = new MarketReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketCollectedFees$Type extends MessageType<MarketCollectedFees> {
    constructor() {
        super("tdex_daemon.v1.MarketCollectedFees", [
            { no: 1, name: "base_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "quote_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketCollectedFees>): MarketCollectedFees {
        const message = { baseAmount: 0, quoteAmount: 0, startDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketCollectedFees>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketCollectedFees): MarketCollectedFees {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 base_amount */ 1:
                    message.baseAmount = reader.uint64().toNumber();
                    break;
                case /* uint64 quote_amount */ 2:
                    message.quoteAmount = reader.uint64().toNumber();
                    break;
                case /* string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 4:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketCollectedFees, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 base_amount = 1; */
        if (message.baseAmount !== 0)
            writer.tag(1, WireType.Varint).uint64(message.baseAmount);
        /* uint64 quote_amount = 2; */
        if (message.quoteAmount !== 0)
            writer.tag(2, WireType.Varint).uint64(message.quoteAmount);
        /* string start_date = 3; */
        if (message.startDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 4; */
        if (message.endDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.MarketCollectedFees
 */
export const MarketCollectedFees = new MarketCollectedFees$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketVolume$Type extends MessageType<MarketVolume> {
    constructor() {
        super("tdex_daemon.v1.MarketVolume", [
            { no: 1, name: "base_volume", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "quote_volume", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketVolume>): MarketVolume {
        const message = { baseVolume: 0, quoteVolume: 0, startDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketVolume): MarketVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 base_volume */ 1:
                    message.baseVolume = reader.uint64().toNumber();
                    break;
                case /* uint64 quote_volume */ 2:
                    message.quoteVolume = reader.uint64().toNumber();
                    break;
                case /* string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 4:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 base_volume = 1; */
        if (message.baseVolume !== 0)
            writer.tag(1, WireType.Varint).uint64(message.baseVolume);
        /* uint64 quote_volume = 2; */
        if (message.quoteVolume !== 0)
            writer.tag(2, WireType.Varint).uint64(message.quoteVolume);
        /* string start_date = 3; */
        if (message.startDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 4; */
        if (message.endDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.MarketVolume
 */
export const MarketVolume = new MarketVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeRange$Type extends MessageType<TimeRange> {
    constructor() {
        super("tdex_daemon.v1.TimeRange", [
            { no: 1, name: "predefined_period", kind: "enum", T: () => ["tdex_daemon.v1.PredefinedPeriod", PredefinedPeriod] },
            { no: 2, name: "custom_period", kind: "message", T: () => CustomPeriod }
        ]);
    }
    create(value?: PartialMessage<TimeRange>): TimeRange {
        const message = { predefinedPeriod: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeRange): TimeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.PredefinedPeriod predefined_period */ 1:
                    message.predefinedPeriod = reader.int32();
                    break;
                case /* tdex_daemon.v1.CustomPeriod custom_period */ 2:
                    message.customPeriod = CustomPeriod.internalBinaryRead(reader, reader.uint32(), options, message.customPeriod);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.PredefinedPeriod predefined_period = 1; */
        if (message.predefinedPeriod !== 0)
            writer.tag(1, WireType.Varint).int32(message.predefinedPeriod);
        /* tdex_daemon.v1.CustomPeriod custom_period = 2; */
        if (message.customPeriod)
            CustomPeriod.internalBinaryWrite(message.customPeriod, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.TimeRange
 */
export const TimeRange = new TimeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomPeriod$Type extends MessageType<CustomPeriod> {
    constructor() {
        super("tdex_daemon.v1.CustomPeriod", [
            { no: 1, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CustomPeriod>): CustomPeriod {
        const message = { startDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomPeriod>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomPeriod): CustomPeriod {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string start_date */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 2:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomPeriod, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string start_date = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.CustomPeriod
 */
export const CustomPeriod = new CustomPeriod$Type();
