/* eslint-disable */
// @generated by protobuf-ts 2.7.0 with parameter add_pb_suffix,eslint_disable,ts_nocheck,keep_enum_prefix,long_type_number
// @generated from protobuf file "tdex-daemon/v1/operator.proto" (package "tdex_daemon.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MarketReport } from "./types_pb";
import { TimeFrame } from "./types_pb";
import { TimeRange } from "./types_pb";
import { Withdrawal } from "./types_pb";
import { Deposit } from "./types_pb";
import { WebhookInfo } from "./types_pb";
import { ActionType } from "./types_pb";
import { UtxoInfo } from "./types_pb";
import { TradeInfo } from "./types_pb";
import { BalanceInfo } from "./types_pb";
import { StrategyType } from "./types_pb";
import { Price } from "../../tdex/v1/types_pb";
import { Fixed } from "../../tdex/v1/types_pb";
import { MarketWithFee } from "../../tdex/v1/types_pb";
import { FeeInfo } from "./types_pb";
import { Page } from "./types_pb";
import { Balance } from "../../tdex/v1/types_pb";
import { MarketInfo } from "./types_pb";
import { Market } from "../../tdex/v1/types_pb";
import { Outpoint } from "./types_pb";
import { AddressWithBlindingKey } from "./types_pb";
import { AccountInfo } from "./types_pb";
/**
 * @generated from protobuf message tdex_daemon.v1.GetInfoRequest
 */
export interface GetInfoRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetInfoResponse
 */
export interface GetInfoResponse {
    /**
     * The root path of the wallet of the daemon.
     *
     * @generated from protobuf field: string root_path = 1;
     */
    rootPath: string;
    /**
     * The SLIP-77 master blinding key from which every keypair is derived.
     *
     * @generated from protobuf field: string master_blinding_key = 2;
     */
    masterBlindingKey: string;
    /**
     * The list of info related to every account.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.AccountInfo account_info = 3;
     */
    accountInfo: AccountInfo[];
    /**
     * Network daemon running on
     *
     * @generated from protobuf field: string network = 4;
     */
    network: string;
    /**
     * Daemon build information
     *
     * @generated from protobuf field: tdex_daemon.v1.BuildInfo build_data = 5;
     */
    buildData?: BuildInfo;
    /**
     * Fixed base asset
     *
     * @generated from protobuf field: string fixed_base_asset = 6;
     */
    fixedBaseAsset: string;
    /**
     * Fixed quote asset
     *
     * @generated from protobuf field: string fixed_quote_asset = 7;
     */
    fixedQuoteAsset: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.BuildInfo
 */
export interface BuildInfo {
    /**
     * Version
     *
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * Commit
     *
     * @generated from protobuf field: string commit = 2;
     */
    commit: string;
    /**
     * Date
     *
     * @generated from protobuf field: string date = 3;
     */
    date: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeAddressRequest
 */
export interface GetFeeAddressRequest {
    /**
     * The number of addresses to generate.
     *
     * @generated from protobuf field: int64 num_of_addresses = 1;
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeAddressResponse
 */
export interface GetFeeAddressResponse {
    /**
     * The list of new confidential addresses and related private blinding keys.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListFeeAddressesRequest
 */
export interface ListFeeAddressesRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListFeeAddressesResponse
 */
export interface ListFeeAddressesResponse {
    /**
     * The list of derived confidential addresses and related private blinding
     * keys.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeBalanceRequest
 */
export interface GetFeeBalanceRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeBalanceResponse
 */
export interface GetFeeBalanceResponse {
    /**
     * The balance of all unlocked unspents.
     *
     * @generated from protobuf field: uint64 available_balance = 1;
     */
    availableBalance: number;
    /**
     * The balance of all unspents included those locked.
     *
     * @generated from protobuf field: uint64 total_balance = 2;
     */
    totalBalance: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ClaimFeeDepositsRequest
 */
export interface ClaimFeeDepositsRequest {
    /**
     * The list of outpoints sent to the fee account address(es).
     * They all must be confirmed, ie. included in blockchain.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.Outpoint outpoints = 1;
     */
    outpoints: Outpoint[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ClaimFeeDepositsResponse
 */
export interface ClaimFeeDepositsResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawFeeRequest
 */
export interface WithdrawFeeRequest {
    /**
     * The amount of L-BTC to widthdraw expressed in Satoshi.
     *
     * @generated from protobuf field: uint64 amount = 1;
     */
    amount: number;
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
    /**
     * The address to send the funds to.
     *
     * @generated from protobuf field: string address = 3;
     */
    address: string;
    /**
     * The asset to withdraw. To leave blank for LBTC. This is aimed for
     * those cases where the operator deposits funds with assets diffent from LBTC
     * into the Fee account and than needs to withdraw'em.
     *
     * @generated from protobuf field: string asset = 4;
     */
    asset: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawFeeResponse
 */
export interface WithdrawFeeResponse {
    /**
     * The transaction hash in mempool/blockchain.
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.NewMarketRequest
 */
export interface NewMarketRequest {
    /**
     * The asset pair for which creating a new account in the daemon's wallet.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.NewMarketResponse
 */
export interface NewMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketInfoRequest
 */
export interface GetMarketInfoRequest {
    /**
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketInfoResponse
 */
export interface GetMarketInfoResponse {
    /**
     * @generated from protobuf field: tdex_daemon.v1.MarketInfo info = 1;
     */
    info?: MarketInfo;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketAddressRequest
 */
export interface GetMarketAddressRequest {
    /**
     * The market for which deriving new addresses.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The number of addresses to generate.
     *
     * @generated from protobuf field: int64 num_of_addresses = 2;
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketAddressResponse
 */
export interface GetMarketAddressResponse {
    /**
     * The list of new confidential addresses and related private blinding keys.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListMarketAddressesRequest
 */
export interface ListMarketAddressesRequest {
    /**
     * The Market for which listing all derived addresses.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListMarketAddressesResponse
 */
export interface ListMarketAddressesResponse {
    /**
     * The list of derived confidential addresses and related private blinding
     * keys.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketBalanceRequest
 */
export interface GetMarketBalanceRequest {
    /**
     * The market for which calculating the balance.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketBalanceResponse
 */
export interface GetMarketBalanceResponse {
    /**
     * The balance of all unlocked unspents.
     *
     * @generated from protobuf field: tdex.v1.Balance available_balance = 1;
     */
    availableBalance?: Balance;
    /**
     * The balance of all unspents included those locked.
     *
     * @generated from protobuf field: tdex.v1.Balance total_balance = 2;
     */
    totalBalance?: Balance;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ClaimMarketDepositsRequest
 */
export interface ClaimMarketDepositsRequest {
    /**
     * The market for which claiming the deposits.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The list of outpoints sent to the market address(es).
     * They all must be confirmed, ie. included in blockchain.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.Outpoint outpoints = 2;
     */
    outpoints: Outpoint[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ClaimMarketDepositsResponse
 */
export interface ClaimMarketDepositsResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.OpenMarketRequest
 */
export interface OpenMarketRequest {
    /**
     * The market to be made tradable.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.OpenMarketResponse
 */
export interface OpenMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.CloseMarketRequest
 */
export interface CloseMarketRequest {
    /**
     * The market to be made not tradable.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.CloseMarketResponse
 */
export interface CloseMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListMarketsRequest
 */
export interface ListMarketsRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListMarketsResponse
 */
export interface ListMarketsResponse {
    /**
     * The list of info about all the created markets.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.MarketInfo markets = 1;
     */
    markets: MarketInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.DropMarketRequest
 */
export interface DropMarketRequest {
    /**
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v1.DropMarketResponse
 */
export interface DropMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketCollectedSwapFeesRequest
 */
export interface GetMarketCollectedSwapFeesRequest {
    /**
     * The marker for which returning the report of collected fees.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v1.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketCollectedSwapFeesResponse
 */
export interface GetMarketCollectedSwapFeesResponse {
    /**
     * The list of info about the collected fees per each trade.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.FeeInfo collected_fees = 1;
     */
    collectedFees: FeeInfo[];
    /**
     * The map of total fees collected per asset.
     *
     * @generated from protobuf field: map<string, int64> total_collected_fees_per_asset = 2;
     */
    totalCollectedFeesPerAsset: {
        [key: string]: number;
    };
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawMarketRequest
 */
export interface WithdrawMarketRequest {
    /**
     * The market from which funds should be withdrawn.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The amount of base and quote asset to be withdrawn.
     *
     * @generated from protobuf field: tdex.v1.Balance balance_to_withdraw = 2;
     */
    balanceToWithdraw?: Balance;
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: int64 millisats_per_byte = 3;
     */
    millisatsPerByte: number;
    /**
     * The address to send the funds to.
     *
     * @generated from protobuf field: string address = 4;
     */
    address: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawMarketResponse
 */
export interface WithdrawMarketResponse {
    /**
     * The transaction hash in mempool/blockchain.
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketPercentageFeeRequest
 */
export interface UpdateMarketPercentageFeeRequest {
    /**
     * The market for which updating the percentage fee.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new percentage fee expresses in basis point.
     *
     * @generated from protobuf field: int64 basis_point = 2;
     */
    basisPoint: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketPercentageFeeResponse
 */
export interface UpdateMarketPercentageFeeResponse {
    /**
     * The market with updated fees.
     *
     * @generated from protobuf field: tdex.v1.MarketWithFee market_with_fee = 1;
     */
    marketWithFee?: MarketWithFee;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketFixedFeeRequest
 */
export interface UpdateMarketFixedFeeRequest {
    /**
     * The market for which updating the fixed fee.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new fixed fee for base and quote asset.
     *
     * @generated from protobuf field: tdex.v1.Fixed fixed = 2;
     */
    fixed?: Fixed;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketFixedFeeResponse
 */
export interface UpdateMarketFixedFeeResponse {
    /**
     * The market with updated fees.
     *
     * @generated from protobuf field: tdex.v1.MarketWithFee market_with_fee = 1;
     */
    marketWithFee?: MarketWithFee;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketPriceRequest
 */
export interface UpdateMarketPriceRequest {
    /**
     * The arket for which updating the price.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new price for base and quote asset.
     *
     * @generated from protobuf field: tdex.v1.Price price = 2;
     */
    price?: Price;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketPriceResponse
 */
export interface UpdateMarketPriceResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketStrategyRequest
 */
export interface UpdateMarketStrategyRequest {
    /**
     * The market for which changing the strategy.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new making strategy to use.
     *
     * @generated from protobuf field: tdex_daemon.v1.StrategyType strategy_type = 2;
     */
    strategyType: StrategyType;
    /**
     * The JSON string representing additional metadata about the new strategy.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.UpdateMarketStrategyResponse
 */
export interface UpdateMarketStrategyResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeFragmenterAddressRequest
 */
export interface GetFeeFragmenterAddressRequest {
    /**
     * @generated from protobuf field: int64 num_of_addresses = 1;
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeFragmenterAddressResponse
 */
export interface GetFeeFragmenterAddressResponse {
    /**
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListFeeFragmenterAddressesRequest
 */
export interface ListFeeFragmenterAddressesRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListFeeFragmenterAddressesResponse
 */
export interface ListFeeFragmenterAddressesResponse {
    /**
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeFragmenterBalanceRequest
 */
export interface GetFeeFragmenterBalanceRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetFeeFragmenterBalanceResponse
 */
export interface GetFeeFragmenterBalanceResponse {
    /**
     * The balance info (total, confirmed, unconfirmed) of the account grouped by
     * asset.
     *
     * @generated from protobuf field: map<string, tdex_daemon.v1.BalanceInfo> balance = 1;
     */
    balance: {
        [key: string]: BalanceInfo;
    };
}
/**
 * @generated from protobuf message tdex_daemon.v1.FeeFragmenterSplitFundsRequest
 */
export interface FeeFragmenterSplitFundsRequest {
    /**
     * The max number of fragments the fragmenter can generate when splitting
     * its funds.
     *
     * @generated from protobuf field: uint32 max_fragments = 1;
     */
    maxFragments: number;
    /**
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.FeeFragmenterSplitFundsResponse
 */
export interface FeeFragmenterSplitFundsResponse {
    /**
     * A sequence of string messages returned during the process.
     *
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawFeeFragmenterRequest
 */
export interface WithdrawFeeFragmenterRequest {
    /**
     * The address to send the funds to.
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawFeeFragmenterResponse
 */
export interface WithdrawFeeFragmenterResponse {
    /**
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketFragmenterAddressRequest
 */
export interface GetMarketFragmenterAddressRequest {
    /**
     * @generated from protobuf field: int64 num_of_addresses = 1;
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketFragmenterAddressResponse
 */
export interface GetMarketFragmenterAddressResponse {
    /**
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListMarketFragmenterAddressesRequest
 */
export interface ListMarketFragmenterAddressesRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListMarketFragmenterAddressesResponse
 */
export interface ListMarketFragmenterAddressesResponse {
    /**
     * @generated from protobuf field: repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1;
     */
    addressWithBlindingKey: AddressWithBlindingKey[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketFragmenterBalanceRequest
 */
export interface GetMarketFragmenterBalanceRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketFragmenterBalanceResponse
 */
export interface GetMarketFragmenterBalanceResponse {
    /**
     * The balance info (total, confirmed, unconfirmed) of the account grouped by
     * asset.
     *
     * @generated from protobuf field: map<string, tdex_daemon.v1.BalanceInfo> balance = 1;
     */
    balance: {
        [key: string]: BalanceInfo;
    };
}
/**
 * @generated from protobuf message tdex_daemon.v1.MarketFragmenterSplitFundsRequest
 */
export interface MarketFragmenterSplitFundsRequest {
    /**
     * The market to which to deposit the fragmented funds owned by the market
     * fragmenter.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.MarketFragmenterSplitFundsResponse
 */
export interface MarketFragmenterSplitFundsResponse {
    /**
     * A sequence of string messages returned during the process.
     *
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawMarketFragmenterRequest
 */
export interface WithdrawMarketFragmenterRequest {
    /**
     * The address to send the funds to.
     *
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
}
/**
 * @generated from protobuf message tdex_daemon.v1.WithdrawMarketFragmenterResponse
 */
export interface WithdrawMarketFragmenterResponse {
    /**
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListTradesRequest
 */
export interface ListTradesRequest {
    /**
     * Optional: request all trades related to a specific market.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v1.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListTradesResponse
 */
export interface ListTradesResponse {
    /**
     * The list of info about all trades or all trades for a market depending on
     * the request.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.TradeInfo trades = 1;
     */
    trades: TradeInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ReloadUtxosRequest
 */
export interface ReloadUtxosRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ReloadUtxosResponse
 */
export interface ReloadUtxosResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListUtxosRequest
 */
export interface ListUtxosRequest {
    /**
     * Optional: request all utxos owned by a specific wallet account.
     *
     * @generated from protobuf field: uint64 account_index = 1;
     */
    accountIndex: number;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v1.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListUtxosResponse
 */
export interface ListUtxosResponse {
    /**
     * The list of all unspent utxos.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.UtxoInfo unspents = 1;
     */
    unspents: UtxoInfo[];
    /**
     * The list of all spent utxos.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.UtxoInfo spents = 2;
     */
    spents: UtxoInfo[];
    /**
     * The list of all currently locked utxos.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.UtxoInfo locks = 3;
     */
    locks: UtxoInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.AddWebhookRequest
 */
export interface AddWebhookRequest {
    /**
     * The endpoint of the external service to reach.
     *
     * @generated from protobuf field: string endpoint = 1;
     */
    endpoint: string;
    /**
     * The action for which the webhook should be registered.
     *
     * @generated from protobuf field: tdex_daemon.v1.ActionType action = 2;
     */
    action: ActionType;
    /**
     * The secret to use for signign a JWT token for an authenticated request
     * to the external service.
     *
     * @generated from protobuf field: string secret = 3;
     */
    secret: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.AddWebhookResponse
 */
export interface AddWebhookResponse {
    /**
     * The id of the new webhook.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.RemoveWebhookRequest
 */
export interface RemoveWebhookRequest {
    /**
     * The id of the webhook to remove.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message tdex_daemon.v1.RemoveWebhookResponse
 */
export interface RemoveWebhookResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListWebhooksRequest
 */
export interface ListWebhooksRequest {
    /**
     * The action for which filtering the list of webhooks.
     *
     * @generated from protobuf field: tdex_daemon.v1.ActionType action = 1;
     */
    action: ActionType;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListWebhooksResponse
 */
export interface ListWebhooksResponse {
    /**
     * The list of info about the webhooks regitered for an action.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.WebhookInfo webhook_info = 1;
     */
    webhookInfo: WebhookInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListDepositsRequest
 */
export interface ListDepositsRequest {
    /**
     * The index of the wallet account for which listing the deposits.
     *
     * @generated from protobuf field: int64 account_index = 1;
     */
    accountIndex: number;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v1.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListDepositsResponse
 */
export interface ListDepositsResponse {
    /**
     * The index of the wallet account.
     *
     * @generated from protobuf field: int64 account_index = 1;
     */
    accountIndex: number;
    /**
     * The list of info about the deposits.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.Deposit deposits = 2;
     */
    deposits: Deposit[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListWithdrawalsRequest
 */
export interface ListWithdrawalsRequest {
    /**
     * The index of the wallet account for which listing the withdrawals.
     *
     * @generated from protobuf field: int64 account_index = 1;
     */
    accountIndex: number;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v1.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v1.ListWithdrawalsResponse
 */
export interface ListWithdrawalsResponse {
    /**
     * The index of the wallet account.
     *
     * @generated from protobuf field: int64 account_index = 1;
     */
    accountIndex: number;
    /**
     * The list of info about the withdrawals.
     *
     * @generated from protobuf field: repeated tdex_daemon.v1.Withdrawal withdrawals = 2;
     */
    withdrawals: Withdrawal[];
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketReportRequest
 */
export interface GetMarketReportRequest {
    /**
     * The market for which returning the report of collected fees.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * time_range fetch market report from time range
     *
     * @generated from protobuf field: tdex_daemon.v1.TimeRange time_range = 2;
     */
    timeRange?: TimeRange;
    /**
     * used to group volume by time_frame for the specified time_range
     *
     * @generated from protobuf field: tdex_daemon.v1.TimeFrame time_frame = 3;
     */
    timeFrame: TimeFrame;
}
/**
 * @generated from protobuf message tdex_daemon.v1.GetMarketReportResponse
 */
export interface GetMarketReportResponse {
    /**
     * MarketReport holds info about volume and collected fees
     *
     * @generated from protobuf field: tdex_daemon.v1.MarketReport report = 1;
     */
    report?: MarketReport;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoRequest$Type extends MessageType<GetInfoRequest> {
    constructor() {
        super("tdex_daemon.v1.GetInfoRequest", []);
    }
    create(value?: PartialMessage<GetInfoRequest>): GetInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoRequest): GetInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetInfoRequest
 */
export const GetInfoRequest = new GetInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetInfoResponse$Type extends MessageType<GetInfoResponse> {
    constructor() {
        super("tdex_daemon.v1.GetInfoResponse", [
            { no: 1, name: "root_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "master_blinding_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AccountInfo },
            { no: 4, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "build_data", kind: "message", T: () => BuildInfo },
            { no: 6, name: "fixed_base_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "fixed_quote_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetInfoResponse>): GetInfoResponse {
        const message = { rootPath: "", masterBlindingKey: "", accountInfo: [], network: "", fixedBaseAsset: "", fixedQuoteAsset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetInfoResponse): GetInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string root_path */ 1:
                    message.rootPath = reader.string();
                    break;
                case /* string master_blinding_key */ 2:
                    message.masterBlindingKey = reader.string();
                    break;
                case /* repeated tdex_daemon.v1.AccountInfo account_info */ 3:
                    message.accountInfo.push(AccountInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string network */ 4:
                    message.network = reader.string();
                    break;
                case /* tdex_daemon.v1.BuildInfo build_data */ 5:
                    message.buildData = BuildInfo.internalBinaryRead(reader, reader.uint32(), options, message.buildData);
                    break;
                case /* string fixed_base_asset */ 6:
                    message.fixedBaseAsset = reader.string();
                    break;
                case /* string fixed_quote_asset */ 7:
                    message.fixedQuoteAsset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string root_path = 1; */
        if (message.rootPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.rootPath);
        /* string master_blinding_key = 2; */
        if (message.masterBlindingKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.masterBlindingKey);
        /* repeated tdex_daemon.v1.AccountInfo account_info = 3; */
        for (let i = 0; i < message.accountInfo.length; i++)
            AccountInfo.internalBinaryWrite(message.accountInfo[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string network = 4; */
        if (message.network !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.network);
        /* tdex_daemon.v1.BuildInfo build_data = 5; */
        if (message.buildData)
            BuildInfo.internalBinaryWrite(message.buildData, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* string fixed_base_asset = 6; */
        if (message.fixedBaseAsset !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.fixedBaseAsset);
        /* string fixed_quote_asset = 7; */
        if (message.fixedQuoteAsset !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.fixedQuoteAsset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetInfoResponse
 */
export const GetInfoResponse = new GetInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildInfo$Type extends MessageType<BuildInfo> {
    constructor() {
        super("tdex_daemon.v1.BuildInfo", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "commit", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<BuildInfo>): BuildInfo {
        const message = { version: "", commit: "", date: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuildInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildInfo): BuildInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string commit */ 2:
                    message.commit = reader.string();
                    break;
                case /* string date */ 3:
                    message.date = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string commit = 2; */
        if (message.commit !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commit);
        /* string date = 3; */
        if (message.date !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.date);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.BuildInfo
 */
export const BuildInfo = new BuildInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeAddressRequest$Type extends MessageType<GetFeeAddressRequest> {
    constructor() {
        super("tdex_daemon.v1.GetFeeAddressRequest", [
            { no: 1, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetFeeAddressRequest>): GetFeeAddressRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeAddressRequest): GetFeeAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_of_addresses */ 1:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeeAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_of_addresses = 1; */
        if (message.numOfAddresses !== 0)
            writer.tag(1, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeAddressRequest
 */
export const GetFeeAddressRequest = new GetFeeAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeAddressResponse$Type extends MessageType<GetFeeAddressResponse> {
    constructor() {
        super("tdex_daemon.v1.GetFeeAddressResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<GetFeeAddressResponse>): GetFeeAddressResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeAddressResponse): GetFeeAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeeAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeAddressResponse
 */
export const GetFeeAddressResponse = new GetFeeAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeAddressesRequest$Type extends MessageType<ListFeeAddressesRequest> {
    constructor() {
        super("tdex_daemon.v1.ListFeeAddressesRequest", []);
    }
    create(value?: PartialMessage<ListFeeAddressesRequest>): ListFeeAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeAddressesRequest): ListFeeAddressesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListFeeAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListFeeAddressesRequest
 */
export const ListFeeAddressesRequest = new ListFeeAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeAddressesResponse$Type extends MessageType<ListFeeAddressesResponse> {
    constructor() {
        super("tdex_daemon.v1.ListFeeAddressesResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<ListFeeAddressesResponse>): ListFeeAddressesResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeAddressesResponse): ListFeeAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFeeAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListFeeAddressesResponse
 */
export const ListFeeAddressesResponse = new ListFeeAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeBalanceRequest$Type extends MessageType<GetFeeBalanceRequest> {
    constructor() {
        super("tdex_daemon.v1.GetFeeBalanceRequest", []);
    }
    create(value?: PartialMessage<GetFeeBalanceRequest>): GetFeeBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeBalanceRequest): GetFeeBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFeeBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeBalanceRequest
 */
export const GetFeeBalanceRequest = new GetFeeBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeBalanceResponse$Type extends MessageType<GetFeeBalanceResponse> {
    constructor() {
        super("tdex_daemon.v1.GetFeeBalanceResponse", [
            { no: 1, name: "available_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "total_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetFeeBalanceResponse>): GetFeeBalanceResponse {
        const message = { availableBalance: 0, totalBalance: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeBalanceResponse): GetFeeBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 available_balance */ 1:
                    message.availableBalance = reader.uint64().toNumber();
                    break;
                case /* uint64 total_balance */ 2:
                    message.totalBalance = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeeBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 available_balance = 1; */
        if (message.availableBalance !== 0)
            writer.tag(1, WireType.Varint).uint64(message.availableBalance);
        /* uint64 total_balance = 2; */
        if (message.totalBalance !== 0)
            writer.tag(2, WireType.Varint).uint64(message.totalBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeBalanceResponse
 */
export const GetFeeBalanceResponse = new GetFeeBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClaimFeeDepositsRequest$Type extends MessageType<ClaimFeeDepositsRequest> {
    constructor() {
        super("tdex_daemon.v1.ClaimFeeDepositsRequest", [
            { no: 1, name: "outpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Outpoint }
        ]);
    }
    create(value?: PartialMessage<ClaimFeeDepositsRequest>): ClaimFeeDepositsRequest {
        const message = { outpoints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClaimFeeDepositsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClaimFeeDepositsRequest): ClaimFeeDepositsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.Outpoint outpoints */ 1:
                    message.outpoints.push(Outpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClaimFeeDepositsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.Outpoint outpoints = 1; */
        for (let i = 0; i < message.outpoints.length; i++)
            Outpoint.internalBinaryWrite(message.outpoints[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ClaimFeeDepositsRequest
 */
export const ClaimFeeDepositsRequest = new ClaimFeeDepositsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClaimFeeDepositsResponse$Type extends MessageType<ClaimFeeDepositsResponse> {
    constructor() {
        super("tdex_daemon.v1.ClaimFeeDepositsResponse", []);
    }
    create(value?: PartialMessage<ClaimFeeDepositsResponse>): ClaimFeeDepositsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClaimFeeDepositsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClaimFeeDepositsResponse): ClaimFeeDepositsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ClaimFeeDepositsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ClaimFeeDepositsResponse
 */
export const ClaimFeeDepositsResponse = new ClaimFeeDepositsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeRequest$Type extends MessageType<WithdrawFeeRequest> {
    constructor() {
        super("tdex_daemon.v1.WithdrawFeeRequest", [
            { no: 1, name: "amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeRequest>): WithdrawFeeRequest {
        const message = { amount: 0, millisatsPerByte: 0, address: "", asset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeRequest): WithdrawFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 amount */ 1:
                    message.amount = reader.uint64().toNumber();
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                case /* string address */ 3:
                    message.address = reader.string();
                    break;
                case /* string asset */ 4:
                    message.asset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 amount = 1; */
        if (message.amount !== 0)
            writer.tag(1, WireType.Varint).uint64(message.amount);
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        /* string address = 3; */
        if (message.address !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.address);
        /* string asset = 4; */
        if (message.asset !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.asset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawFeeRequest
 */
export const WithdrawFeeRequest = new WithdrawFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeResponse$Type extends MessageType<WithdrawFeeResponse> {
    constructor() {
        super("tdex_daemon.v1.WithdrawFeeResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeResponse>): WithdrawFeeResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeResponse): WithdrawFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawFeeResponse
 */
export const WithdrawFeeResponse = new WithdrawFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewMarketRequest$Type extends MessageType<NewMarketRequest> {
    constructor() {
        super("tdex_daemon.v1.NewMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<NewMarketRequest>): NewMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewMarketRequest): NewMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.NewMarketRequest
 */
export const NewMarketRequest = new NewMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewMarketResponse$Type extends MessageType<NewMarketResponse> {
    constructor() {
        super("tdex_daemon.v1.NewMarketResponse", []);
    }
    create(value?: PartialMessage<NewMarketResponse>): NewMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewMarketResponse): NewMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NewMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.NewMarketResponse
 */
export const NewMarketResponse = new NewMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketInfoRequest$Type extends MessageType<GetMarketInfoRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketInfoRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<GetMarketInfoRequest>): GetMarketInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketInfoRequest): GetMarketInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketInfoRequest
 */
export const GetMarketInfoRequest = new GetMarketInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketInfoResponse$Type extends MessageType<GetMarketInfoResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketInfoResponse", [
            { no: 1, name: "info", kind: "message", T: () => MarketInfo }
        ]);
    }
    create(value?: PartialMessage<GetMarketInfoResponse>): GetMarketInfoResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketInfoResponse): GetMarketInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.MarketInfo info */ 1:
                    message.info = MarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.MarketInfo info = 1; */
        if (message.info)
            MarketInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketInfoResponse
 */
export const GetMarketInfoResponse = new GetMarketInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketAddressRequest$Type extends MessageType<GetMarketAddressRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketAddressRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetMarketAddressRequest>): GetMarketAddressRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketAddressRequest): GetMarketAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* int64 num_of_addresses */ 2:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 num_of_addresses = 2; */
        if (message.numOfAddresses !== 0)
            writer.tag(2, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketAddressRequest
 */
export const GetMarketAddressRequest = new GetMarketAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketAddressResponse$Type extends MessageType<GetMarketAddressResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketAddressResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<GetMarketAddressResponse>): GetMarketAddressResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketAddressResponse): GetMarketAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketAddressResponse
 */
export const GetMarketAddressResponse = new GetMarketAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketAddressesRequest$Type extends MessageType<ListMarketAddressesRequest> {
    constructor() {
        super("tdex_daemon.v1.ListMarketAddressesRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<ListMarketAddressesRequest>): ListMarketAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketAddressesRequest): ListMarketAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListMarketAddressesRequest
 */
export const ListMarketAddressesRequest = new ListMarketAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketAddressesResponse$Type extends MessageType<ListMarketAddressesResponse> {
    constructor() {
        super("tdex_daemon.v1.ListMarketAddressesResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<ListMarketAddressesResponse>): ListMarketAddressesResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketAddressesResponse): ListMarketAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListMarketAddressesResponse
 */
export const ListMarketAddressesResponse = new ListMarketAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketBalanceRequest$Type extends MessageType<GetMarketBalanceRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketBalanceRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<GetMarketBalanceRequest>): GetMarketBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketBalanceRequest): GetMarketBalanceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketBalanceRequest
 */
export const GetMarketBalanceRequest = new GetMarketBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketBalanceResponse$Type extends MessageType<GetMarketBalanceResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketBalanceResponse", [
            { no: 1, name: "available_balance", kind: "message", T: () => Balance },
            { no: 2, name: "total_balance", kind: "message", T: () => Balance }
        ]);
    }
    create(value?: PartialMessage<GetMarketBalanceResponse>): GetMarketBalanceResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketBalanceResponse): GetMarketBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Balance available_balance */ 1:
                    message.availableBalance = Balance.internalBinaryRead(reader, reader.uint32(), options, message.availableBalance);
                    break;
                case /* tdex.v1.Balance total_balance */ 2:
                    message.totalBalance = Balance.internalBinaryRead(reader, reader.uint32(), options, message.totalBalance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Balance available_balance = 1; */
        if (message.availableBalance)
            Balance.internalBinaryWrite(message.availableBalance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Balance total_balance = 2; */
        if (message.totalBalance)
            Balance.internalBinaryWrite(message.totalBalance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketBalanceResponse
 */
export const GetMarketBalanceResponse = new GetMarketBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClaimMarketDepositsRequest$Type extends MessageType<ClaimMarketDepositsRequest> {
    constructor() {
        super("tdex_daemon.v1.ClaimMarketDepositsRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "outpoints", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Outpoint }
        ]);
    }
    create(value?: PartialMessage<ClaimMarketDepositsRequest>): ClaimMarketDepositsRequest {
        const message = { outpoints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClaimMarketDepositsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClaimMarketDepositsRequest): ClaimMarketDepositsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* repeated tdex_daemon.v1.Outpoint outpoints */ 2:
                    message.outpoints.push(Outpoint.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClaimMarketDepositsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v1.Outpoint outpoints = 2; */
        for (let i = 0; i < message.outpoints.length; i++)
            Outpoint.internalBinaryWrite(message.outpoints[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ClaimMarketDepositsRequest
 */
export const ClaimMarketDepositsRequest = new ClaimMarketDepositsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClaimMarketDepositsResponse$Type extends MessageType<ClaimMarketDepositsResponse> {
    constructor() {
        super("tdex_daemon.v1.ClaimMarketDepositsResponse", []);
    }
    create(value?: PartialMessage<ClaimMarketDepositsResponse>): ClaimMarketDepositsResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClaimMarketDepositsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClaimMarketDepositsResponse): ClaimMarketDepositsResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ClaimMarketDepositsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ClaimMarketDepositsResponse
 */
export const ClaimMarketDepositsResponse = new ClaimMarketDepositsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenMarketRequest$Type extends MessageType<OpenMarketRequest> {
    constructor() {
        super("tdex_daemon.v1.OpenMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<OpenMarketRequest>): OpenMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenMarketRequest): OpenMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.OpenMarketRequest
 */
export const OpenMarketRequest = new OpenMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenMarketResponse$Type extends MessageType<OpenMarketResponse> {
    constructor() {
        super("tdex_daemon.v1.OpenMarketResponse", []);
    }
    create(value?: PartialMessage<OpenMarketResponse>): OpenMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenMarketResponse): OpenMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: OpenMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.OpenMarketResponse
 */
export const OpenMarketResponse = new OpenMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseMarketRequest$Type extends MessageType<CloseMarketRequest> {
    constructor() {
        super("tdex_daemon.v1.CloseMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<CloseMarketRequest>): CloseMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseMarketRequest): CloseMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.CloseMarketRequest
 */
export const CloseMarketRequest = new CloseMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseMarketResponse$Type extends MessageType<CloseMarketResponse> {
    constructor() {
        super("tdex_daemon.v1.CloseMarketResponse", []);
    }
    create(value?: PartialMessage<CloseMarketResponse>): CloseMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseMarketResponse): CloseMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CloseMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.CloseMarketResponse
 */
export const CloseMarketResponse = new CloseMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketsRequest$Type extends MessageType<ListMarketsRequest> {
    constructor() {
        super("tdex_daemon.v1.ListMarketsRequest", []);
    }
    create(value?: PartialMessage<ListMarketsRequest>): ListMarketsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketsRequest): ListMarketsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListMarketsRequest
 */
export const ListMarketsRequest = new ListMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketsResponse$Type extends MessageType<ListMarketsResponse> {
    constructor() {
        super("tdex_daemon.v1.ListMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketInfo }
        ]);
    }
    create(value?: PartialMessage<ListMarketsResponse>): ListMarketsResponse {
        const message = { markets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketsResponse): ListMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.MarketInfo markets */ 1:
                    message.markets.push(MarketInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.MarketInfo markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            MarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListMarketsResponse
 */
export const ListMarketsResponse = new ListMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropMarketRequest$Type extends MessageType<DropMarketRequest> {
    constructor() {
        super("tdex_daemon.v1.DropMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<DropMarketRequest>): DropMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DropMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DropMarketRequest): DropMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DropMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.DropMarketRequest
 */
export const DropMarketRequest = new DropMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropMarketResponse$Type extends MessageType<DropMarketResponse> {
    constructor() {
        super("tdex_daemon.v1.DropMarketResponse", []);
    }
    create(value?: PartialMessage<DropMarketResponse>): DropMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DropMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DropMarketResponse): DropMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DropMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.DropMarketResponse
 */
export const DropMarketResponse = new DropMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketCollectedSwapFeesRequest$Type extends MessageType<GetMarketCollectedSwapFeesRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketCollectedSwapFeesRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<GetMarketCollectedSwapFeesRequest>): GetMarketCollectedSwapFeesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketCollectedSwapFeesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketCollectedSwapFeesRequest): GetMarketCollectedSwapFeesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v1.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketCollectedSwapFeesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketCollectedSwapFeesRequest
 */
export const GetMarketCollectedSwapFeesRequest = new GetMarketCollectedSwapFeesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketCollectedSwapFeesResponse$Type extends MessageType<GetMarketCollectedSwapFeesResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketCollectedSwapFeesResponse", [
            { no: 1, name: "collected_fees", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FeeInfo },
            { no: 2, name: "total_collected_fees_per_asset", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ } }
        ]);
    }
    create(value?: PartialMessage<GetMarketCollectedSwapFeesResponse>): GetMarketCollectedSwapFeesResponse {
        const message = { collectedFees: [], totalCollectedFeesPerAsset: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketCollectedSwapFeesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketCollectedSwapFeesResponse): GetMarketCollectedSwapFeesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.FeeInfo collected_fees */ 1:
                    message.collectedFees.push(FeeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, int64> total_collected_fees_per_asset */ 2:
                    this.binaryReadMap2(message.totalCollectedFeesPerAsset, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: GetMarketCollectedSwapFeesResponse["totalCollectedFeesPerAsset"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetMarketCollectedSwapFeesResponse["totalCollectedFeesPerAsset"] | undefined, val: GetMarketCollectedSwapFeesResponse["totalCollectedFeesPerAsset"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int64().toNumber();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v1.GetMarketCollectedSwapFeesResponse.total_collected_fees_per_asset");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: GetMarketCollectedSwapFeesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.FeeInfo collected_fees = 1; */
        for (let i = 0; i < message.collectedFees.length; i++)
            FeeInfo.internalBinaryWrite(message.collectedFees[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* map<string, int64> total_collected_fees_per_asset = 2; */
        for (let k of Object.keys(message.totalCollectedFeesPerAsset))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int64(message.totalCollectedFeesPerAsset[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketCollectedSwapFeesResponse
 */
export const GetMarketCollectedSwapFeesResponse = new GetMarketCollectedSwapFeesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketRequest$Type extends MessageType<WithdrawMarketRequest> {
    constructor() {
        super("tdex_daemon.v1.WithdrawMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "balance_to_withdraw", kind: "message", T: () => Balance },
            { no: 3, name: "millisats_per_byte", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketRequest>): WithdrawMarketRequest {
        const message = { millisatsPerByte: 0, address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketRequest): WithdrawMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Balance balance_to_withdraw */ 2:
                    message.balanceToWithdraw = Balance.internalBinaryRead(reader, reader.uint32(), options, message.balanceToWithdraw);
                    break;
                case /* int64 millisats_per_byte */ 3:
                    message.millisatsPerByte = reader.int64().toNumber();
                    break;
                case /* string address */ 4:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Balance balance_to_withdraw = 2; */
        if (message.balanceToWithdraw)
            Balance.internalBinaryWrite(message.balanceToWithdraw, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 millisats_per_byte = 3; */
        if (message.millisatsPerByte !== 0)
            writer.tag(3, WireType.Varint).int64(message.millisatsPerByte);
        /* string address = 4; */
        if (message.address !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawMarketRequest
 */
export const WithdrawMarketRequest = new WithdrawMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketResponse$Type extends MessageType<WithdrawMarketResponse> {
    constructor() {
        super("tdex_daemon.v1.WithdrawMarketResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketResponse>): WithdrawMarketResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketResponse): WithdrawMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawMarketResponse
 */
export const WithdrawMarketResponse = new WithdrawMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPercentageFeeRequest$Type extends MessageType<UpdateMarketPercentageFeeRequest> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketPercentageFeeRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "basis_point", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketPercentageFeeRequest>): UpdateMarketPercentageFeeRequest {
        const message = { basisPoint: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPercentageFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPercentageFeeRequest): UpdateMarketPercentageFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* int64 basis_point */ 2:
                    message.basisPoint = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketPercentageFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 basis_point = 2; */
        if (message.basisPoint !== 0)
            writer.tag(2, WireType.Varint).int64(message.basisPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketPercentageFeeRequest
 */
export const UpdateMarketPercentageFeeRequest = new UpdateMarketPercentageFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPercentageFeeResponse$Type extends MessageType<UpdateMarketPercentageFeeResponse> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketPercentageFeeResponse", [
            { no: 1, name: "market_with_fee", kind: "message", T: () => MarketWithFee }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketPercentageFeeResponse>): UpdateMarketPercentageFeeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPercentageFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPercentageFeeResponse): UpdateMarketPercentageFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.MarketWithFee market_with_fee */ 1:
                    message.marketWithFee = MarketWithFee.internalBinaryRead(reader, reader.uint32(), options, message.marketWithFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketPercentageFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.MarketWithFee market_with_fee = 1; */
        if (message.marketWithFee)
            MarketWithFee.internalBinaryWrite(message.marketWithFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketPercentageFeeResponse
 */
export const UpdateMarketPercentageFeeResponse = new UpdateMarketPercentageFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketFixedFeeRequest$Type extends MessageType<UpdateMarketFixedFeeRequest> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketFixedFeeRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "fixed", kind: "message", T: () => Fixed }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketFixedFeeRequest>): UpdateMarketFixedFeeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketFixedFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketFixedFeeRequest): UpdateMarketFixedFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Fixed fixed */ 2:
                    message.fixed = Fixed.internalBinaryRead(reader, reader.uint32(), options, message.fixed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketFixedFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Fixed fixed = 2; */
        if (message.fixed)
            Fixed.internalBinaryWrite(message.fixed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketFixedFeeRequest
 */
export const UpdateMarketFixedFeeRequest = new UpdateMarketFixedFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketFixedFeeResponse$Type extends MessageType<UpdateMarketFixedFeeResponse> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketFixedFeeResponse", [
            { no: 1, name: "market_with_fee", kind: "message", T: () => MarketWithFee }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketFixedFeeResponse>): UpdateMarketFixedFeeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketFixedFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketFixedFeeResponse): UpdateMarketFixedFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.MarketWithFee market_with_fee */ 1:
                    message.marketWithFee = MarketWithFee.internalBinaryRead(reader, reader.uint32(), options, message.marketWithFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketFixedFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.MarketWithFee market_with_fee = 1; */
        if (message.marketWithFee)
            MarketWithFee.internalBinaryWrite(message.marketWithFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketFixedFeeResponse
 */
export const UpdateMarketFixedFeeResponse = new UpdateMarketFixedFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPriceRequest$Type extends MessageType<UpdateMarketPriceRequest> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketPriceRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "price", kind: "message", T: () => Price }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketPriceRequest>): UpdateMarketPriceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPriceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPriceRequest): UpdateMarketPriceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Price price */ 2:
                    message.price = Price.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketPriceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Price price = 2; */
        if (message.price)
            Price.internalBinaryWrite(message.price, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketPriceRequest
 */
export const UpdateMarketPriceRequest = new UpdateMarketPriceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPriceResponse$Type extends MessageType<UpdateMarketPriceResponse> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketPriceResponse", []);
    }
    create(value?: PartialMessage<UpdateMarketPriceResponse>): UpdateMarketPriceResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPriceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPriceResponse): UpdateMarketPriceResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateMarketPriceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketPriceResponse
 */
export const UpdateMarketPriceResponse = new UpdateMarketPriceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketStrategyRequest$Type extends MessageType<UpdateMarketStrategyRequest> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketStrategyRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "strategy_type", kind: "enum", T: () => ["tdex_daemon.v1.StrategyType", StrategyType] },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketStrategyRequest>): UpdateMarketStrategyRequest {
        const message = { strategyType: 0, metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketStrategyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketStrategyRequest): UpdateMarketStrategyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v1.StrategyType strategy_type */ 2:
                    message.strategyType = reader.int32();
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketStrategyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.StrategyType strategy_type = 2; */
        if (message.strategyType !== 0)
            writer.tag(2, WireType.Varint).int32(message.strategyType);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketStrategyRequest
 */
export const UpdateMarketStrategyRequest = new UpdateMarketStrategyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketStrategyResponse$Type extends MessageType<UpdateMarketStrategyResponse> {
    constructor() {
        super("tdex_daemon.v1.UpdateMarketStrategyResponse", []);
    }
    create(value?: PartialMessage<UpdateMarketStrategyResponse>): UpdateMarketStrategyResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketStrategyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketStrategyResponse): UpdateMarketStrategyResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateMarketStrategyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.UpdateMarketStrategyResponse
 */
export const UpdateMarketStrategyResponse = new UpdateMarketStrategyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeFragmenterAddressRequest$Type extends MessageType<GetFeeFragmenterAddressRequest> {
    constructor() {
        super("tdex_daemon.v1.GetFeeFragmenterAddressRequest", [
            { no: 1, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetFeeFragmenterAddressRequest>): GetFeeFragmenterAddressRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeFragmenterAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeFragmenterAddressRequest): GetFeeFragmenterAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_of_addresses */ 1:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeeFragmenterAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_of_addresses = 1; */
        if (message.numOfAddresses !== 0)
            writer.tag(1, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeFragmenterAddressRequest
 */
export const GetFeeFragmenterAddressRequest = new GetFeeFragmenterAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeFragmenterAddressResponse$Type extends MessageType<GetFeeFragmenterAddressResponse> {
    constructor() {
        super("tdex_daemon.v1.GetFeeFragmenterAddressResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<GetFeeFragmenterAddressResponse>): GetFeeFragmenterAddressResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeFragmenterAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeFragmenterAddressResponse): GetFeeFragmenterAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeeFragmenterAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeFragmenterAddressResponse
 */
export const GetFeeFragmenterAddressResponse = new GetFeeFragmenterAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeFragmenterAddressesRequest$Type extends MessageType<ListFeeFragmenterAddressesRequest> {
    constructor() {
        super("tdex_daemon.v1.ListFeeFragmenterAddressesRequest", []);
    }
    create(value?: PartialMessage<ListFeeFragmenterAddressesRequest>): ListFeeFragmenterAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeFragmenterAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeFragmenterAddressesRequest): ListFeeFragmenterAddressesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListFeeFragmenterAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListFeeFragmenterAddressesRequest
 */
export const ListFeeFragmenterAddressesRequest = new ListFeeFragmenterAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeFragmenterAddressesResponse$Type extends MessageType<ListFeeFragmenterAddressesResponse> {
    constructor() {
        super("tdex_daemon.v1.ListFeeFragmenterAddressesResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<ListFeeFragmenterAddressesResponse>): ListFeeFragmenterAddressesResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeFragmenterAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeFragmenterAddressesResponse): ListFeeFragmenterAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFeeFragmenterAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListFeeFragmenterAddressesResponse
 */
export const ListFeeFragmenterAddressesResponse = new ListFeeFragmenterAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeFragmenterBalanceRequest$Type extends MessageType<GetFeeFragmenterBalanceRequest> {
    constructor() {
        super("tdex_daemon.v1.GetFeeFragmenterBalanceRequest", []);
    }
    create(value?: PartialMessage<GetFeeFragmenterBalanceRequest>): GetFeeFragmenterBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeFragmenterBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeFragmenterBalanceRequest): GetFeeFragmenterBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFeeFragmenterBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeFragmenterBalanceRequest
 */
export const GetFeeFragmenterBalanceRequest = new GetFeeFragmenterBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeFragmenterBalanceResponse$Type extends MessageType<GetFeeFragmenterBalanceResponse> {
    constructor() {
        super("tdex_daemon.v1.GetFeeFragmenterBalanceResponse", [
            { no: 1, name: "balance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => BalanceInfo } }
        ]);
    }
    create(value?: PartialMessage<GetFeeFragmenterBalanceResponse>): GetFeeFragmenterBalanceResponse {
        const message = { balance: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeFragmenterBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeFragmenterBalanceResponse): GetFeeFragmenterBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, tdex_daemon.v1.BalanceInfo> balance */ 1:
                    this.binaryReadMap1(message.balance, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetFeeFragmenterBalanceResponse["balance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetFeeFragmenterBalanceResponse["balance"] | undefined, val: GetFeeFragmenterBalanceResponse["balance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = BalanceInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v1.GetFeeFragmenterBalanceResponse.balance");
            }
        }
        map[key ?? ""] = val ?? BalanceInfo.create();
    }
    internalBinaryWrite(message: GetFeeFragmenterBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, tdex_daemon.v1.BalanceInfo> balance = 1; */
        for (let k of Object.keys(message.balance)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            BalanceInfo.internalBinaryWrite(message.balance[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetFeeFragmenterBalanceResponse
 */
export const GetFeeFragmenterBalanceResponse = new GetFeeFragmenterBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeFragmenterSplitFundsRequest$Type extends MessageType<FeeFragmenterSplitFundsRequest> {
    constructor() {
        super("tdex_daemon.v1.FeeFragmenterSplitFundsRequest", [
            { no: 1, name: "max_fragments", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<FeeFragmenterSplitFundsRequest>): FeeFragmenterSplitFundsRequest {
        const message = { maxFragments: 0, millisatsPerByte: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeFragmenterSplitFundsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeFragmenterSplitFundsRequest): FeeFragmenterSplitFundsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 max_fragments */ 1:
                    message.maxFragments = reader.uint32();
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeFragmenterSplitFundsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 max_fragments = 1; */
        if (message.maxFragments !== 0)
            writer.tag(1, WireType.Varint).uint32(message.maxFragments);
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.FeeFragmenterSplitFundsRequest
 */
export const FeeFragmenterSplitFundsRequest = new FeeFragmenterSplitFundsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeFragmenterSplitFundsResponse$Type extends MessageType<FeeFragmenterSplitFundsResponse> {
    constructor() {
        super("tdex_daemon.v1.FeeFragmenterSplitFundsResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeeFragmenterSplitFundsResponse>): FeeFragmenterSplitFundsResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeFragmenterSplitFundsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeFragmenterSplitFundsResponse): FeeFragmenterSplitFundsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeFragmenterSplitFundsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.FeeFragmenterSplitFundsResponse
 */
export const FeeFragmenterSplitFundsResponse = new FeeFragmenterSplitFundsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeFragmenterRequest$Type extends MessageType<WithdrawFeeFragmenterRequest> {
    constructor() {
        super("tdex_daemon.v1.WithdrawFeeFragmenterRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeFragmenterRequest>): WithdrawFeeFragmenterRequest {
        const message = { address: "", millisatsPerByte: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeFragmenterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeFragmenterRequest): WithdrawFeeFragmenterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeFragmenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawFeeFragmenterRequest
 */
export const WithdrawFeeFragmenterRequest = new WithdrawFeeFragmenterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeFragmenterResponse$Type extends MessageType<WithdrawFeeFragmenterResponse> {
    constructor() {
        super("tdex_daemon.v1.WithdrawFeeFragmenterResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeFragmenterResponse>): WithdrawFeeFragmenterResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeFragmenterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeFragmenterResponse): WithdrawFeeFragmenterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeFragmenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawFeeFragmenterResponse
 */
export const WithdrawFeeFragmenterResponse = new WithdrawFeeFragmenterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketFragmenterAddressRequest$Type extends MessageType<GetMarketFragmenterAddressRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketFragmenterAddressRequest", [
            { no: 1, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetMarketFragmenterAddressRequest>): GetMarketFragmenterAddressRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketFragmenterAddressRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketFragmenterAddressRequest): GetMarketFragmenterAddressRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_of_addresses */ 1:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketFragmenterAddressRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_of_addresses = 1; */
        if (message.numOfAddresses !== 0)
            writer.tag(1, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketFragmenterAddressRequest
 */
export const GetMarketFragmenterAddressRequest = new GetMarketFragmenterAddressRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketFragmenterAddressResponse$Type extends MessageType<GetMarketFragmenterAddressResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketFragmenterAddressResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<GetMarketFragmenterAddressResponse>): GetMarketFragmenterAddressResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketFragmenterAddressResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketFragmenterAddressResponse): GetMarketFragmenterAddressResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketFragmenterAddressResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketFragmenterAddressResponse
 */
export const GetMarketFragmenterAddressResponse = new GetMarketFragmenterAddressResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketFragmenterAddressesRequest$Type extends MessageType<ListMarketFragmenterAddressesRequest> {
    constructor() {
        super("tdex_daemon.v1.ListMarketFragmenterAddressesRequest", []);
    }
    create(value?: PartialMessage<ListMarketFragmenterAddressesRequest>): ListMarketFragmenterAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketFragmenterAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketFragmenterAddressesRequest): ListMarketFragmenterAddressesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListMarketFragmenterAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListMarketFragmenterAddressesRequest
 */
export const ListMarketFragmenterAddressesRequest = new ListMarketFragmenterAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketFragmenterAddressesResponse$Type extends MessageType<ListMarketFragmenterAddressesResponse> {
    constructor() {
        super("tdex_daemon.v1.ListMarketFragmenterAddressesResponse", [
            { no: 1, name: "address_with_blinding_key", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AddressWithBlindingKey }
        ]);
    }
    create(value?: PartialMessage<ListMarketFragmenterAddressesResponse>): ListMarketFragmenterAddressesResponse {
        const message = { addressWithBlindingKey: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketFragmenterAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketFragmenterAddressesResponse): ListMarketFragmenterAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key */ 1:
                    message.addressWithBlindingKey.push(AddressWithBlindingKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketFragmenterAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.AddressWithBlindingKey address_with_blinding_key = 1; */
        for (let i = 0; i < message.addressWithBlindingKey.length; i++)
            AddressWithBlindingKey.internalBinaryWrite(message.addressWithBlindingKey[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListMarketFragmenterAddressesResponse
 */
export const ListMarketFragmenterAddressesResponse = new ListMarketFragmenterAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketFragmenterBalanceRequest$Type extends MessageType<GetMarketFragmenterBalanceRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketFragmenterBalanceRequest", []);
    }
    create(value?: PartialMessage<GetMarketFragmenterBalanceRequest>): GetMarketFragmenterBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketFragmenterBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketFragmenterBalanceRequest): GetMarketFragmenterBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMarketFragmenterBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketFragmenterBalanceRequest
 */
export const GetMarketFragmenterBalanceRequest = new GetMarketFragmenterBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketFragmenterBalanceResponse$Type extends MessageType<GetMarketFragmenterBalanceResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketFragmenterBalanceResponse", [
            { no: 1, name: "balance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => BalanceInfo } }
        ]);
    }
    create(value?: PartialMessage<GetMarketFragmenterBalanceResponse>): GetMarketFragmenterBalanceResponse {
        const message = { balance: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketFragmenterBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketFragmenterBalanceResponse): GetMarketFragmenterBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, tdex_daemon.v1.BalanceInfo> balance */ 1:
                    this.binaryReadMap1(message.balance, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetMarketFragmenterBalanceResponse["balance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetMarketFragmenterBalanceResponse["balance"] | undefined, val: GetMarketFragmenterBalanceResponse["balance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = BalanceInfo.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v1.GetMarketFragmenterBalanceResponse.balance");
            }
        }
        map[key ?? ""] = val ?? BalanceInfo.create();
    }
    internalBinaryWrite(message: GetMarketFragmenterBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, tdex_daemon.v1.BalanceInfo> balance = 1; */
        for (let k of Object.keys(message.balance)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            BalanceInfo.internalBinaryWrite(message.balance[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketFragmenterBalanceResponse
 */
export const GetMarketFragmenterBalanceResponse = new GetMarketFragmenterBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketFragmenterSplitFundsRequest$Type extends MessageType<MarketFragmenterSplitFundsRequest> {
    constructor() {
        super("tdex_daemon.v1.MarketFragmenterSplitFundsRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<MarketFragmenterSplitFundsRequest>): MarketFragmenterSplitFundsRequest {
        const message = { millisatsPerByte: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketFragmenterSplitFundsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketFragmenterSplitFundsRequest): MarketFragmenterSplitFundsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketFragmenterSplitFundsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.MarketFragmenterSplitFundsRequest
 */
export const MarketFragmenterSplitFundsRequest = new MarketFragmenterSplitFundsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketFragmenterSplitFundsResponse$Type extends MessageType<MarketFragmenterSplitFundsResponse> {
    constructor() {
        super("tdex_daemon.v1.MarketFragmenterSplitFundsResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketFragmenterSplitFundsResponse>): MarketFragmenterSplitFundsResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketFragmenterSplitFundsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketFragmenterSplitFundsResponse): MarketFragmenterSplitFundsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketFragmenterSplitFundsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.MarketFragmenterSplitFundsResponse
 */
export const MarketFragmenterSplitFundsResponse = new MarketFragmenterSplitFundsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketFragmenterRequest$Type extends MessageType<WithdrawMarketFragmenterRequest> {
    constructor() {
        super("tdex_daemon.v1.WithdrawMarketFragmenterRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketFragmenterRequest>): WithdrawMarketFragmenterRequest {
        const message = { address: "", millisatsPerByte: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketFragmenterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketFragmenterRequest): WithdrawMarketFragmenterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketFragmenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawMarketFragmenterRequest
 */
export const WithdrawMarketFragmenterRequest = new WithdrawMarketFragmenterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketFragmenterResponse$Type extends MessageType<WithdrawMarketFragmenterResponse> {
    constructor() {
        super("tdex_daemon.v1.WithdrawMarketFragmenterResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketFragmenterResponse>): WithdrawMarketFragmenterResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketFragmenterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketFragmenterResponse): WithdrawMarketFragmenterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketFragmenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.WithdrawMarketFragmenterResponse
 */
export const WithdrawMarketFragmenterResponse = new WithdrawMarketFragmenterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTradesRequest$Type extends MessageType<ListTradesRequest> {
    constructor() {
        super("tdex_daemon.v1.ListTradesRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListTradesRequest>): ListTradesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTradesRequest): ListTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v1.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListTradesRequest
 */
export const ListTradesRequest = new ListTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTradesResponse$Type extends MessageType<ListTradesResponse> {
    constructor() {
        super("tdex_daemon.v1.ListTradesResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TradeInfo }
        ]);
    }
    create(value?: PartialMessage<ListTradesResponse>): ListTradesResponse {
        const message = { trades: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTradesResponse): ListTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.TradeInfo trades */ 1:
                    message.trades.push(TradeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.TradeInfo trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            TradeInfo.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListTradesResponse
 */
export const ListTradesResponse = new ListTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadUtxosRequest$Type extends MessageType<ReloadUtxosRequest> {
    constructor() {
        super("tdex_daemon.v1.ReloadUtxosRequest", []);
    }
    create(value?: PartialMessage<ReloadUtxosRequest>): ReloadUtxosRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReloadUtxosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadUtxosRequest): ReloadUtxosRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReloadUtxosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ReloadUtxosRequest
 */
export const ReloadUtxosRequest = new ReloadUtxosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReloadUtxosResponse$Type extends MessageType<ReloadUtxosResponse> {
    constructor() {
        super("tdex_daemon.v1.ReloadUtxosResponse", []);
    }
    create(value?: PartialMessage<ReloadUtxosResponse>): ReloadUtxosResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReloadUtxosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReloadUtxosResponse): ReloadUtxosResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReloadUtxosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ReloadUtxosResponse
 */
export const ReloadUtxosResponse = new ReloadUtxosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUtxosRequest$Type extends MessageType<ListUtxosRequest> {
    constructor() {
        super("tdex_daemon.v1.ListUtxosRequest", [
            { no: 1, name: "account_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListUtxosRequest>): ListUtxosRequest {
        const message = { accountIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUtxosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUtxosRequest): ListUtxosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 account_index */ 1:
                    message.accountIndex = reader.uint64().toNumber();
                    break;
                case /* tdex_daemon.v1.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUtxosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 account_index = 1; */
        if (message.accountIndex !== 0)
            writer.tag(1, WireType.Varint).uint64(message.accountIndex);
        /* tdex_daemon.v1.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListUtxosRequest
 */
export const ListUtxosRequest = new ListUtxosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUtxosResponse$Type extends MessageType<ListUtxosResponse> {
    constructor() {
        super("tdex_daemon.v1.ListUtxosResponse", [
            { no: 1, name: "unspents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoInfo },
            { no: 2, name: "spents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoInfo },
            { no: 3, name: "locks", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoInfo }
        ]);
    }
    create(value?: PartialMessage<ListUtxosResponse>): ListUtxosResponse {
        const message = { unspents: [], spents: [], locks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUtxosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUtxosResponse): ListUtxosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.UtxoInfo unspents */ 1:
                    message.unspents.push(UtxoInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tdex_daemon.v1.UtxoInfo spents */ 2:
                    message.spents.push(UtxoInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tdex_daemon.v1.UtxoInfo locks */ 3:
                    message.locks.push(UtxoInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUtxosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.UtxoInfo unspents = 1; */
        for (let i = 0; i < message.unspents.length; i++)
            UtxoInfo.internalBinaryWrite(message.unspents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v1.UtxoInfo spents = 2; */
        for (let i = 0; i < message.spents.length; i++)
            UtxoInfo.internalBinaryWrite(message.spents[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v1.UtxoInfo locks = 3; */
        for (let i = 0; i < message.locks.length; i++)
            UtxoInfo.internalBinaryWrite(message.locks[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListUtxosResponse
 */
export const ListUtxosResponse = new ListUtxosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddWebhookRequest$Type extends MessageType<AddWebhookRequest> {
    constructor() {
        super("tdex_daemon.v1.AddWebhookRequest", [
            { no: 1, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "enum", T: () => ["tdex_daemon.v1.ActionType", ActionType] },
            { no: 3, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddWebhookRequest>): AddWebhookRequest {
        const message = { endpoint: "", action: 0, secret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddWebhookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddWebhookRequest): AddWebhookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string endpoint */ 1:
                    message.endpoint = reader.string();
                    break;
                case /* tdex_daemon.v1.ActionType action */ 2:
                    message.action = reader.int32();
                    break;
                case /* string secret */ 3:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddWebhookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string endpoint = 1; */
        if (message.endpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.endpoint);
        /* tdex_daemon.v1.ActionType action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        /* string secret = 3; */
        if (message.secret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.AddWebhookRequest
 */
export const AddWebhookRequest = new AddWebhookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddWebhookResponse$Type extends MessageType<AddWebhookResponse> {
    constructor() {
        super("tdex_daemon.v1.AddWebhookResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddWebhookResponse>): AddWebhookResponse {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddWebhookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddWebhookResponse): AddWebhookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddWebhookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.AddWebhookResponse
 */
export const AddWebhookResponse = new AddWebhookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveWebhookRequest$Type extends MessageType<RemoveWebhookRequest> {
    constructor() {
        super("tdex_daemon.v1.RemoveWebhookRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveWebhookRequest>): RemoveWebhookRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveWebhookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveWebhookRequest): RemoveWebhookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveWebhookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.RemoveWebhookRequest
 */
export const RemoveWebhookRequest = new RemoveWebhookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveWebhookResponse$Type extends MessageType<RemoveWebhookResponse> {
    constructor() {
        super("tdex_daemon.v1.RemoveWebhookResponse", []);
    }
    create(value?: PartialMessage<RemoveWebhookResponse>): RemoveWebhookResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveWebhookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveWebhookResponse): RemoveWebhookResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RemoveWebhookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.RemoveWebhookResponse
 */
export const RemoveWebhookResponse = new RemoveWebhookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWebhooksRequest$Type extends MessageType<ListWebhooksRequest> {
    constructor() {
        super("tdex_daemon.v1.ListWebhooksRequest", [
            { no: 1, name: "action", kind: "enum", T: () => ["tdex_daemon.v1.ActionType", ActionType] }
        ]);
    }
    create(value?: PartialMessage<ListWebhooksRequest>): ListWebhooksRequest {
        const message = { action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWebhooksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWebhooksRequest): ListWebhooksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.ActionType action */ 1:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWebhooksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.ActionType action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListWebhooksRequest
 */
export const ListWebhooksRequest = new ListWebhooksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWebhooksResponse$Type extends MessageType<ListWebhooksResponse> {
    constructor() {
        super("tdex_daemon.v1.ListWebhooksResponse", [
            { no: 1, name: "webhook_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WebhookInfo }
        ]);
    }
    create(value?: PartialMessage<ListWebhooksResponse>): ListWebhooksResponse {
        const message = { webhookInfo: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWebhooksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWebhooksResponse): ListWebhooksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v1.WebhookInfo webhook_info */ 1:
                    message.webhookInfo.push(WebhookInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWebhooksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v1.WebhookInfo webhook_info = 1; */
        for (let i = 0; i < message.webhookInfo.length; i++)
            WebhookInfo.internalBinaryWrite(message.webhookInfo[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListWebhooksResponse
 */
export const ListWebhooksResponse = new ListWebhooksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDepositsRequest$Type extends MessageType<ListDepositsRequest> {
    constructor() {
        super("tdex_daemon.v1.ListDepositsRequest", [
            { no: 1, name: "account_index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListDepositsRequest>): ListDepositsRequest {
        const message = { accountIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDepositsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDepositsRequest): ListDepositsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 account_index */ 1:
                    message.accountIndex = reader.int64().toNumber();
                    break;
                case /* tdex_daemon.v1.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDepositsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 account_index = 1; */
        if (message.accountIndex !== 0)
            writer.tag(1, WireType.Varint).int64(message.accountIndex);
        /* tdex_daemon.v1.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListDepositsRequest
 */
export const ListDepositsRequest = new ListDepositsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDepositsResponse$Type extends MessageType<ListDepositsResponse> {
    constructor() {
        super("tdex_daemon.v1.ListDepositsResponse", [
            { no: 1, name: "account_index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "deposits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Deposit }
        ]);
    }
    create(value?: PartialMessage<ListDepositsResponse>): ListDepositsResponse {
        const message = { accountIndex: 0, deposits: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDepositsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDepositsResponse): ListDepositsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 account_index */ 1:
                    message.accountIndex = reader.int64().toNumber();
                    break;
                case /* repeated tdex_daemon.v1.Deposit deposits */ 2:
                    message.deposits.push(Deposit.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDepositsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 account_index = 1; */
        if (message.accountIndex !== 0)
            writer.tag(1, WireType.Varint).int64(message.accountIndex);
        /* repeated tdex_daemon.v1.Deposit deposits = 2; */
        for (let i = 0; i < message.deposits.length; i++)
            Deposit.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListDepositsResponse
 */
export const ListDepositsResponse = new ListDepositsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWithdrawalsRequest$Type extends MessageType<ListWithdrawalsRequest> {
    constructor() {
        super("tdex_daemon.v1.ListWithdrawalsRequest", [
            { no: 1, name: "account_index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListWithdrawalsRequest>): ListWithdrawalsRequest {
        const message = { accountIndex: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWithdrawalsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWithdrawalsRequest): ListWithdrawalsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 account_index */ 1:
                    message.accountIndex = reader.int64().toNumber();
                    break;
                case /* tdex_daemon.v1.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWithdrawalsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 account_index = 1; */
        if (message.accountIndex !== 0)
            writer.tag(1, WireType.Varint).int64(message.accountIndex);
        /* tdex_daemon.v1.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListWithdrawalsRequest
 */
export const ListWithdrawalsRequest = new ListWithdrawalsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWithdrawalsResponse$Type extends MessageType<ListWithdrawalsResponse> {
    constructor() {
        super("tdex_daemon.v1.ListWithdrawalsResponse", [
            { no: 1, name: "account_index", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "withdrawals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Withdrawal }
        ]);
    }
    create(value?: PartialMessage<ListWithdrawalsResponse>): ListWithdrawalsResponse {
        const message = { accountIndex: 0, withdrawals: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWithdrawalsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWithdrawalsResponse): ListWithdrawalsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 account_index */ 1:
                    message.accountIndex = reader.int64().toNumber();
                    break;
                case /* repeated tdex_daemon.v1.Withdrawal withdrawals */ 2:
                    message.withdrawals.push(Withdrawal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWithdrawalsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 account_index = 1; */
        if (message.accountIndex !== 0)
            writer.tag(1, WireType.Varint).int64(message.accountIndex);
        /* repeated tdex_daemon.v1.Withdrawal withdrawals = 2; */
        for (let i = 0; i < message.withdrawals.length; i++)
            Withdrawal.internalBinaryWrite(message.withdrawals[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.ListWithdrawalsResponse
 */
export const ListWithdrawalsResponse = new ListWithdrawalsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketReportRequest$Type extends MessageType<GetMarketReportRequest> {
    constructor() {
        super("tdex_daemon.v1.GetMarketReportRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "time_range", kind: "message", T: () => TimeRange },
            { no: 3, name: "time_frame", kind: "enum", T: () => ["tdex_daemon.v1.TimeFrame", TimeFrame] }
        ]);
    }
    create(value?: PartialMessage<GetMarketReportRequest>): GetMarketReportRequest {
        const message = { timeFrame: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketReportRequest): GetMarketReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v1.TimeRange time_range */ 2:
                    message.timeRange = TimeRange.internalBinaryRead(reader, reader.uint32(), options, message.timeRange);
                    break;
                case /* tdex_daemon.v1.TimeFrame time_frame */ 3:
                    message.timeFrame = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.TimeRange time_range = 2; */
        if (message.timeRange)
            TimeRange.internalBinaryWrite(message.timeRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v1.TimeFrame time_frame = 3; */
        if (message.timeFrame !== 0)
            writer.tag(3, WireType.Varint).int32(message.timeFrame);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketReportRequest
 */
export const GetMarketReportRequest = new GetMarketReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketReportResponse$Type extends MessageType<GetMarketReportResponse> {
    constructor() {
        super("tdex_daemon.v1.GetMarketReportResponse", [
            { no: 1, name: "report", kind: "message", T: () => MarketReport }
        ]);
    }
    create(value?: PartialMessage<GetMarketReportResponse>): GetMarketReportResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketReportResponse): GetMarketReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v1.MarketReport report */ 1:
                    message.report = MarketReport.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v1.MarketReport report = 1; */
        if (message.report)
            MarketReport.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v1.GetMarketReportResponse
 */
export const GetMarketReportResponse = new GetMarketReportResponse$Type();
/**
 * @generated ServiceType for protobuf service tdex_daemon.v1.OperatorService
 */
export const OperatorService = new ServiceType("tdex_daemon.v1.OperatorService", [
    { name: "GetInfo", options: {}, I: GetInfoRequest, O: GetInfoResponse },
    { name: "GetFeeAddress", options: {}, I: GetFeeAddressRequest, O: GetFeeAddressResponse },
    { name: "ListFeeAddresses", options: {}, I: ListFeeAddressesRequest, O: ListFeeAddressesResponse },
    { name: "GetFeeBalance", options: {}, I: GetFeeBalanceRequest, O: GetFeeBalanceResponse },
    { name: "ClaimFeeDeposits", options: {}, I: ClaimFeeDepositsRequest, O: ClaimFeeDepositsResponse },
    { name: "WithdrawFee", options: {}, I: WithdrawFeeRequest, O: WithdrawFeeResponse },
    { name: "NewMarket", options: {}, I: NewMarketRequest, O: NewMarketResponse },
    { name: "GetMarketInfo", options: {}, I: GetMarketInfoRequest, O: GetMarketInfoResponse },
    { name: "GetMarketAddress", options: {}, I: GetMarketAddressRequest, O: GetMarketAddressResponse },
    { name: "ListMarketAddresses", options: {}, I: ListMarketAddressesRequest, O: ListMarketAddressesResponse },
    { name: "GetMarketBalance", options: {}, I: GetMarketBalanceRequest, O: GetMarketBalanceResponse },
    { name: "ClaimMarketDeposits", options: {}, I: ClaimMarketDepositsRequest, O: ClaimMarketDepositsResponse },
    { name: "OpenMarket", options: {}, I: OpenMarketRequest, O: OpenMarketResponse },
    { name: "CloseMarket", options: {}, I: CloseMarketRequest, O: CloseMarketResponse },
    { name: "DropMarket", options: {}, I: DropMarketRequest, O: DropMarketResponse },
    { name: "GetMarketCollectedSwapFees", options: {}, I: GetMarketCollectedSwapFeesRequest, O: GetMarketCollectedSwapFeesResponse },
    { name: "WithdrawMarket", options: {}, I: WithdrawMarketRequest, O: WithdrawMarketResponse },
    { name: "UpdateMarketPercentageFee", options: {}, I: UpdateMarketPercentageFeeRequest, O: UpdateMarketPercentageFeeResponse },
    { name: "UpdateMarketFixedFee", options: {}, I: UpdateMarketFixedFeeRequest, O: UpdateMarketFixedFeeResponse },
    { name: "UpdateMarketPrice", options: {}, I: UpdateMarketPriceRequest, O: UpdateMarketPriceResponse },
    { name: "UpdateMarketStrategy", options: {}, I: UpdateMarketStrategyRequest, O: UpdateMarketStrategyResponse },
    { name: "GetFeeFragmenterAddress", options: {}, I: GetFeeFragmenterAddressRequest, O: GetFeeFragmenterAddressResponse },
    { name: "ListFeeFragmenterAddresses", options: {}, I: ListFeeFragmenterAddressesRequest, O: ListFeeFragmenterAddressesResponse },
    { name: "GetFeeFragmenterBalance", options: {}, I: GetFeeFragmenterBalanceRequest, O: GetFeeFragmenterBalanceResponse },
    { name: "FeeFragmenterSplitFunds", serverStreaming: true, options: {}, I: FeeFragmenterSplitFundsRequest, O: FeeFragmenterSplitFundsResponse },
    { name: "WithdrawFeeFragmenter", options: {}, I: WithdrawFeeFragmenterRequest, O: WithdrawFeeFragmenterResponse },
    { name: "GetMarketFragmenterAddress", options: {}, I: GetMarketFragmenterAddressRequest, O: GetMarketFragmenterAddressResponse },
    { name: "ListMarketFragmenterAddresses", options: {}, I: ListMarketFragmenterAddressesRequest, O: ListMarketFragmenterAddressesResponse },
    { name: "GetMarketFragmenterBalance", options: {}, I: GetMarketFragmenterBalanceRequest, O: GetMarketFragmenterBalanceResponse },
    { name: "MarketFragmenterSplitFunds", serverStreaming: true, options: {}, I: MarketFragmenterSplitFundsRequest, O: MarketFragmenterSplitFundsResponse },
    { name: "WithdrawMarketFragmenter", options: {}, I: WithdrawMarketFragmenterRequest, O: WithdrawMarketFragmenterResponse },
    { name: "ListMarkets", options: {}, I: ListMarketsRequest, O: ListMarketsResponse },
    { name: "ListTrades", options: {}, I: ListTradesRequest, O: ListTradesResponse },
    { name: "ReloadUtxos", options: {}, I: ReloadUtxosRequest, O: ReloadUtxosResponse },
    { name: "ListUtxos", options: {}, I: ListUtxosRequest, O: ListUtxosResponse },
    { name: "AddWebhook", options: {}, I: AddWebhookRequest, O: AddWebhookResponse },
    { name: "RemoveWebhook", options: {}, I: RemoveWebhookRequest, O: RemoveWebhookResponse },
    { name: "ListWebhooks", options: {}, I: ListWebhooksRequest, O: ListWebhooksResponse },
    { name: "ListDeposits", options: {}, I: ListDepositsRequest, O: ListDepositsResponse },
    { name: "ListWithdrawals", options: {}, I: ListWithdrawalsRequest, O: ListWithdrawalsResponse },
    { name: "GetMarketReport", options: {}, I: GetMarketReportRequest, O: GetMarketReportResponse }
]);
