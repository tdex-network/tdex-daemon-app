/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter add_pb_suffix,eslint_disable,ts_nocheck,keep_enum_prefix,long_type_number
// @generated from protobuf file "tdex-daemon/v2/types.proto" (package "tdex_daemon.v2", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MarketWithFee } from "../../tdex/v1/types_pb";
import { Price } from "../../tdex/v1/types_pb";
import { Fee } from "../../tdex/v1/types_pb";
import { Market } from "../../tdex/v1/types_pb";
/**
 * @generated from protobuf message tdex_daemon.v2.AccountInfo
 */
export interface AccountInfo {
    /**
     * The name of the wallet account.
     *
     * @generated from protobuf field: string account_name = 2;
     */
    accountName: string;
    /**
     * The full derivation path.
     *
     * @generated from protobuf field: string derivation_path = 3;
     */
    derivationPath: string;
    /**
     * The master public key.
     *
     * @generated from protobuf field: repeated string xpubs = 4;
     */
    xpubs: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.MarketInfo
 */
export interface MarketInfo {
    /**
     * The asset pair of the market
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The percentage and fixed fees
     *
     * @generated from protobuf field: tdex.v1.Fee fee = 2;
     */
    fee?: Fee;
    /**
     * Whether the market is opened or closed.
     *
     * @generated from protobuf field: bool tradable = 3;
     */
    tradable: boolean;
    /**
     * The making strategy.
     *
     * @generated from protobuf field: tdex_daemon.v2.StrategyType strategy_type = 4;
     */
    strategyType: StrategyType;
    /**
     * The name of the wallet account.
     *
     * @generated from protobuf field: string account_name = 5;
     */
    accountName: string;
    /**
     * The current price in case the strategy is PLUGGABLE.
     *
     * @generated from protobuf field: tdex.v1.Price price = 6;
     */
    price?: Price;
    /**
     * The current unlocked balance.
     *
     * @generated from protobuf field: map<string, tdex_daemon.v2.Balance> balance = 7;
     */
    balance: {
        [key: string]: Balance;
    };
}
/**
 * @generated from protobuf message tdex_daemon.v2.UtxoInfo
 */
export interface UtxoInfo {
    /**
     * The outpoint <hash, index>
     *
     * @generated from protobuf field: tdex_daemon.v2.Outpoint outpoint = 1;
     */
    outpoint?: Outpoint;
    /**
     * The unblinded value.
     *
     * @generated from protobuf field: uint64 value = 2;
     */
    value: number;
    /**
     * The unblinded asset.
     *
     * @generated from protobuf field: string asset = 3;
     */
    asset: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.TradeStatusInfo
 */
export interface TradeStatusInfo {
    /**
     * The status of the trade.
     *
     * @generated from protobuf field: tdex_daemon.v2.TradeStatus status = 1;
     */
    status: TradeStatus;
    /**
     * Whether it is failed in the current status.
     *
     * @generated from protobuf field: bool failed = 2;
     */
    failed: boolean;
}
/**
 * @generated from protobuf message tdex_daemon.v2.SwapInfo
 */
export interface SwapInfo {
    /**
     * The proposer's quantity.
     *
     * @generated from protobuf field: uint64 amount_p = 1;
     */
    amountP: number;
    /**
     * The proposer's asset hash.
     *
     * @generated from protobuf field: string asset_p = 2;
     */
    assetP: string;
    /**
     * The responder's quantity.
     *
     * @generated from protobuf field: uint64 amount_r = 3;
     */
    amountR: number;
    /**
     * The responder's asset hash.
     *
     * @generated from protobuf field: string asset_r = 4;
     */
    assetR: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.SwapFailInfo
 */
export interface SwapFailInfo {
    /**
     * The error code.
     *
     * @generated from protobuf field: uint32 failure_code = 1;
     */
    failureCode: number;
    /**
     * The error message.
     *
     * @generated from protobuf field: string failure_message = 2;
     */
    failureMessage: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.TradeInfo
 */
export interface TradeInfo {
    /**
     * The id of the trade.
     *
     * @generated from protobuf field: string trade_id = 1;
     */
    tradeId: string;
    /**
     * The info about the status of the trade.
     *
     * @generated from protobuf field: tdex_daemon.v2.TradeStatusInfo status = 2;
     */
    status?: TradeStatusInfo;
    /**
     * The info about the swap.
     *
     * @generated from protobuf field: tdex_daemon.v2.SwapInfo swap_info = 3;
     */
    swapInfo?: SwapInfo;
    /**
     * The info of an eventually failed swap.
     *
     * @generated from protobuf field: tdex_daemon.v2.SwapFailInfo fail_info = 4;
     */
    failInfo?: SwapFailInfo;
    /**
     * The collected fee on the current swap.
     *
     * @generated from protobuf field: tdex.v1.MarketWithFee market_with_fee = 5;
     */
    marketWithFee?: MarketWithFee;
    /**
     * The prices of the trade at request time.
     *
     * @generated from protobuf field: tdex.v1.Price price = 6;
     */
    price?: Price;
    /**
     * The unix timestamp of the SwapRequest.
     *
     * @generated from protobuf field: int64 request_timestamp = 7;
     */
    requestTimestamp: number;
    /**
     * The unix timestamp SwapAccept.
     *
     * @generated from protobuf field: int64 accept_timestamp = 8;
     */
    acceptTimestamp: number;
    /**
     * The unix timestamp of the SwapComplete.
     *
     * @generated from protobuf field: int64 complete_timestamp = 9;
     */
    completeTimestamp: number;
    /**
     * The unix timestamp of the settlement date.
     *
     * @generated from protobuf field: int64 settle_timestamp = 10;
     */
    settleTimestamp: number;
    /**
     * The unix timestamp of the expiration date.
     *
     * @generated from protobuf field: int64 expiry_timestamp = 11;
     */
    expiryTimestamp: number;
    /**
     * The timestamp of the SwapRequest in RFC3339 format.
     *
     * @generated from protobuf field: string request_date = 12;
     */
    requestDate: string;
    /**
     * The timestamp of the SwapAccept in RFC3339 format.
     *
     * @generated from protobuf field: string accept_date = 13;
     */
    acceptDate: string;
    /**
     * The timestamp of the SwapComplete in RFC3339 format.
     *
     * @generated from protobuf field: string complete_date = 14;
     */
    completeDate: string;
    /**
     * The timestamp of the settlement date in RFC3339 format.
     *
     * @generated from protobuf field: string settle_date = 15;
     */
    settleDate: string;
    /**
     * The timestamp of the expiration date in RFC3339 format.
     *
     * @generated from protobuf field: string expiry_date = 16;
     */
    expiryDate: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.FeeInfo
 */
export interface FeeInfo {
    /**
     * The id of the trade.
     *
     * @generated from protobuf field: string trade_id = 1;
     */
    tradeId: string;
    /**
     * The percentage fee applied to the trade.
     *
     * @generated from protobuf field: int64 basis_point = 2;
     */
    basisPoint: number;
    /**
     * The asset in which fees are collected.
     *
     * @generated from protobuf field: string asset = 3;
     */
    asset: string;
    /**
     * The amount in satoshi of the percentage fee.
     *
     * @generated from protobuf field: uint64 percentage_fee_amount = 4;
     */
    percentageFeeAmount: number;
    /**
     * The amount in satoshi of the fixed fee.
     *
     * @generated from protobuf field: uint64 fixed_fee_amount = 5;
     */
    fixedFeeAmount: number;
    /**
     * The market price when the trade propoal was accepted.
     *
     * @generated from protobuf field: double market_price = 6;
     */
    marketPrice: number;
    /**
     * The request date of the trade in RFC3339 format.
     *
     * @generated from protobuf field: string request_date = 7;
     */
    requestDate: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.Balance
 */
export interface Balance {
    /**
     * Spendable balance.
     *
     * @generated from protobuf field: uint64 confirmed_balance = 1;
     */
    confirmedBalance: number;
    /**
     * Not yet spendable balance.
     *
     * @generated from protobuf field: uint64 unconfirmed_balance = 2;
     */
    unconfirmedBalance: number;
    /**
     * Not spendable balance.
     *
     * @generated from protobuf field: uint64 locked_balance = 3;
     */
    lockedBalance: number;
    /**
     * The balance of all unspents included those locked.
     *
     * @generated from protobuf field: uint64 total_balance = 4;
     */
    totalBalance: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.TxOutput
 */
export interface TxOutput {
    /**
     * Asset hash.
     *
     * @generated from protobuf field: string asset = 1;
     */
    asset: string;
    /**
     * Spending amount.
     *
     * @generated from protobuf field: uint64 amount = 2;
     */
    amount: number;
    /**
     * Destination output script.
     *
     * @generated from protobuf field: string script = 3;
     */
    script: string;
    /**
     * Blinding key for confidential output.
     *
     * @generated from protobuf field: string blinding_key = 4;
     */
    blindingKey: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.Outpoint
 */
export interface Outpoint {
    /**
     * The hash of the transaction.
     *
     * @generated from protobuf field: string hash = 1;
     */
    hash: string;
    /**
     * The index of the output.
     *
     * @generated from protobuf field: uint32 index = 2;
     */
    index: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WebhookInfo
 */
export interface WebhookInfo {
    /**
     * The id of the webhook.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * The endpoint of the external service to reach.
     *
     * @generated from protobuf field: string endpoint = 2;
     */
    endpoint: string;
    /**
     * Whether the outgoing requests are authenticated.
     *
     * @generated from protobuf field: bool is_secured = 3;
     */
    isSecured: boolean;
    /**
     * The type of the action.
     *
     * @generated from protobuf field: tdex_daemon.v2.ActionType action_type = 4;
     */
    actionType: ActionType;
}
/**
 * @generated from protobuf message tdex_daemon.v2.Transaction
 */
export interface Transaction {
    /**
     * The utxo deposited.
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
    /**
     * Total outputs amount per asset deposited.
     *
     * @generated from protobuf field: map<string, uint64> total_amount_per_asset = 2;
     */
    totalAmountPerAsset: {
        [key: string]: number;
    };
    /**
     * The timestamp of the deposit transaction in Unix format.
     *
     * @generated from protobuf field: int64 timestamp = 3;
     */
    timestamp: number;
    /**
     * The timestamp of the deposit transaction in RFC3339 format.
     *
     * @generated from protobuf field: string date = 4;
     */
    date: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.Page
 */
export interface Page {
    /**
     * The number of the page.
     *
     * @generated from protobuf field: int64 number = 1;
     */
    number: number;
    /**
     * The size of the page, ie the max length the returning list can have.
     *
     * @generated from protobuf field: int64 size = 2;
     */
    size: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.MarketReport
 */
export interface MarketReport {
    /**
     * @generated from protobuf field: tdex_daemon.v2.MarketCollectedFees total_collected_fees = 1;
     */
    totalCollectedFees?: MarketCollectedFees;
    /**
     * @generated from protobuf field: tdex_daemon.v2.MarketVolume total_volume = 2;
     */
    totalVolume?: MarketVolume;
    /**
     * @generated from protobuf field: repeated tdex_daemon.v2.MarketVolume volumes_per_frame = 3;
     */
    volumesPerFrame: MarketVolume[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.MarketCollectedFees
 */
export interface MarketCollectedFees {
    /**
     * @generated from protobuf field: uint64 base_amount = 1;
     */
    baseAmount: number;
    /**
     * @generated from protobuf field: uint64 quote_amount = 2;
     */
    quoteAmount: number;
    /**
     * @generated from protobuf field: repeated tdex_daemon.v2.FeeInfo fees_per_trade = 3;
     */
    feesPerTrade: FeeInfo[];
    /**
     * start_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string start_date = 4;
     */
    startDate: string;
    /**
     * end_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string end_date = 5;
     */
    endDate: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.MarketVolume
 */
export interface MarketVolume {
    /**
     * @generated from protobuf field: uint64 base_volume = 1;
     */
    baseVolume: number;
    /**
     * @generated from protobuf field: uint64 quote_volume = 2;
     */
    quoteVolume: number;
    /**
     * start_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string start_date = 3;
     */
    startDate: string;
    /**
     * end_date in RFC3339 format of the aggregated volume calculation
     *
     * @generated from protobuf field: string end_date = 4;
     */
    endDate: string;
}
/**
 * TimeRange is flexible type used to determine time span for which specific
 * api will fetch data, either one of predefined_period or custom_period should be provided.
 *
 * @generated from protobuf message tdex_daemon.v2.TimeRange
 */
export interface TimeRange {
    /**
     * predefined time_period till now
     *
     * @generated from protobuf field: tdex_daemon.v2.PredefinedPeriod predefined_period = 1;
     */
    predefinedPeriod: PredefinedPeriod;
    /**
     * custom time range
     *
     * @generated from protobuf field: tdex_daemon.v2.CustomPeriod custom_period = 2;
     */
    customPeriod?: CustomPeriod;
}
/**
 * @generated from protobuf message tdex_daemon.v2.CustomPeriod
 */
export interface CustomPeriod {
    /**
     * start_date in RFC3339 format
     *
     * @generated from protobuf field: string start_date = 1;
     */
    startDate: string;
    /**
     * end_date in RFC3339 format
     *
     * @generated from protobuf field: string end_date = 2;
     */
    endDate: string;
}
/**
 * @generated from protobuf enum tdex_daemon.v2.StrategyType
 */
export enum StrategyType {
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_UNSPECIFIED = 0;
     */
    STRATEGY_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_PLUGGABLE = 1;
     */
    STRATEGY_TYPE_PLUGGABLE = 1,
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_BALANCED = 2;
     */
    STRATEGY_TYPE_BALANCED = 2,
    /**
     * @generated from protobuf enum value: STRATEGY_TYPE_UNBALANCED = 3;
     */
    STRATEGY_TYPE_UNBALANCED = 3
}
/**
 * @generated from protobuf enum tdex_daemon.v2.TradeStatus
 */
export enum TradeStatus {
    /**
     * @generated from protobuf enum value: TRADE_STATUS_UNSPECIFIED = 0;
     */
    TRADE_STATUS_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_REQUEST = 1;
     */
    TRADE_STATUS_REQUEST = 1,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_ACCEPT = 2;
     */
    TRADE_STATUS_ACCEPT = 2,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_COMPLETE = 3;
     */
    TRADE_STATUS_COMPLETE = 3,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_SETTLED = 4;
     */
    TRADE_STATUS_SETTLED = 4,
    /**
     * @generated from protobuf enum value: TRADE_STATUS_EXPIRED = 5;
     */
    TRADE_STATUS_EXPIRED = 5
}
/**
 * @generated from protobuf enum tdex_daemon.v2.ActionType
 */
export enum ActionType {
    /**
     * @generated from protobuf enum value: ACTION_TYPE_UNSPECIFIED = 0;
     */
    ACTION_TYPE_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_TRADE_SETTLED = 1;
     */
    ACTION_TYPE_TRADE_SETTLED = 1,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_ACCOUNT_LOW_BALANCE = 2;
     */
    ACTION_TYPE_ACCOUNT_LOW_BALANCE = 2,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_ACCOUNT_WITHDRAW = 3;
     */
    ACTION_TYPE_ACCOUNT_WITHDRAW = 3,
    /**
     * @generated from protobuf enum value: ACTION_TYPE_ALL_ACTIONS = 4;
     */
    ACTION_TYPE_ALL_ACTIONS = 4
}
/**
 * @generated from protobuf enum tdex_daemon.v2.PredefinedPeriod
 */
export enum PredefinedPeriod {
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_UNSPECIFIED = 0;
     */
    PREDEFINED_PERIOD_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_HOUR = 1;
     */
    PREDEFINED_PERIOD_LAST_HOUR = 1,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_DAY = 2;
     */
    PREDEFINED_PERIOD_LAST_DAY = 2,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_WEEK = 3;
     */
    PREDEFINED_PERIOD_LAST_WEEK = 3,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_MONTH = 4;
     */
    PREDEFINED_PERIOD_LAST_MONTH = 4,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_THREE_MONTHS = 5;
     */
    PREDEFINED_PERIOD_LAST_THREE_MONTHS = 5,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_YEAR_TO_DATE = 6;
     */
    PREDEFINED_PERIOD_YEAR_TO_DATE = 6,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_LAST_YEAR = 7;
     */
    PREDEFINED_PERIOD_LAST_YEAR = 7,
    /**
     * @generated from protobuf enum value: PREDEFINED_PERIOD_ALL = 8;
     */
    PREDEFINED_PERIOD_ALL = 8
}
/**
 * @generated from protobuf enum tdex_daemon.v2.TimeFrame
 */
export enum TimeFrame {
    /**
     * @generated from protobuf enum value: TIME_FRAME_UNSPECIFIED = 0;
     */
    TIME_FRAME_UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TIME_FRAME_HOUR = 1;
     */
    TIME_FRAME_HOUR = 1,
    /**
     * @generated from protobuf enum value: TIME_FRAME_FOUR_HOURS = 2;
     */
    TIME_FRAME_FOUR_HOURS = 2,
    /**
     * @generated from protobuf enum value: TIME_FRAME_DAY = 3;
     */
    TIME_FRAME_DAY = 3,
    /**
     * @generated from protobuf enum value: TIME_FRAME_WEEK = 4;
     */
    TIME_FRAME_WEEK = 4,
    /**
     * @generated from protobuf enum value: TIME_FRAME_MONTH = 5;
     */
    TIME_FRAME_MONTH = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class AccountInfo$Type extends MessageType<AccountInfo> {
    constructor() {
        super("tdex_daemon.v2.AccountInfo", [
            { no: 2, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "derivation_path", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "xpubs", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AccountInfo>): AccountInfo {
        const message = { accountName: "", derivationPath: "", xpubs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AccountInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccountInfo): AccountInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 2:
                    message.accountName = reader.string();
                    break;
                case /* string derivation_path */ 3:
                    message.derivationPath = reader.string();
                    break;
                case /* repeated string xpubs */ 4:
                    message.xpubs.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AccountInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 2; */
        if (message.accountName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.accountName);
        /* string derivation_path = 3; */
        if (message.derivationPath !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.derivationPath);
        /* repeated string xpubs = 4; */
        for (let i = 0; i < message.xpubs.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.xpubs[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.AccountInfo
 */
export const AccountInfo = new AccountInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketInfo$Type extends MessageType<MarketInfo> {
    constructor() {
        super("tdex_daemon.v2.MarketInfo", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "fee", kind: "message", T: () => Fee },
            { no: 3, name: "tradable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "strategy_type", kind: "enum", T: () => ["tdex_daemon.v2.StrategyType", StrategyType] },
            { no: 5, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "price", kind: "message", T: () => Price },
            { no: 7, name: "balance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Balance } }
        ]);
    }
    create(value?: PartialMessage<MarketInfo>): MarketInfo {
        const message = { tradable: false, strategyType: 0, accountName: "", balance: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketInfo): MarketInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Fee fee */ 2:
                    message.fee = Fee.internalBinaryRead(reader, reader.uint32(), options, message.fee);
                    break;
                case /* bool tradable */ 3:
                    message.tradable = reader.bool();
                    break;
                case /* tdex_daemon.v2.StrategyType strategy_type */ 4:
                    message.strategyType = reader.int32();
                    break;
                case /* string account_name */ 5:
                    message.accountName = reader.string();
                    break;
                case /* tdex.v1.Price price */ 6:
                    message.price = Price.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* map<string, tdex_daemon.v2.Balance> balance */ 7:
                    this.binaryReadMap7(message.balance, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap7(map: MarketInfo["balance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MarketInfo["balance"] | undefined, val: MarketInfo["balance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Balance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v2.MarketInfo.balance");
            }
        }
        map[key ?? ""] = val ?? Balance.create();
    }
    internalBinaryWrite(message: MarketInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Fee fee = 2; */
        if (message.fee)
            Fee.internalBinaryWrite(message.fee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* bool tradable = 3; */
        if (message.tradable !== false)
            writer.tag(3, WireType.Varint).bool(message.tradable);
        /* tdex_daemon.v2.StrategyType strategy_type = 4; */
        if (message.strategyType !== 0)
            writer.tag(4, WireType.Varint).int32(message.strategyType);
        /* string account_name = 5; */
        if (message.accountName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.accountName);
        /* tdex.v1.Price price = 6; */
        if (message.price)
            Price.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* map<string, tdex_daemon.v2.Balance> balance = 7; */
        for (let k of Object.keys(message.balance)) {
            writer.tag(7, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Balance.internalBinaryWrite(message.balance[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.MarketInfo
 */
export const MarketInfo = new MarketInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UtxoInfo$Type extends MessageType<UtxoInfo> {
    constructor() {
        super("tdex_daemon.v2.UtxoInfo", [
            { no: 1, name: "outpoint", kind: "message", T: () => Outpoint },
            { no: 2, name: "value", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UtxoInfo>): UtxoInfo {
        const message = { value: 0, asset: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UtxoInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UtxoInfo): UtxoInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.Outpoint outpoint */ 1:
                    message.outpoint = Outpoint.internalBinaryRead(reader, reader.uint32(), options, message.outpoint);
                    break;
                case /* uint64 value */ 2:
                    message.value = reader.uint64().toNumber();
                    break;
                case /* string asset */ 3:
                    message.asset = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UtxoInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.Outpoint outpoint = 1; */
        if (message.outpoint)
            Outpoint.internalBinaryWrite(message.outpoint, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).uint64(message.value);
        /* string asset = 3; */
        if (message.asset !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.asset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UtxoInfo
 */
export const UtxoInfo = new UtxoInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeStatusInfo$Type extends MessageType<TradeStatusInfo> {
    constructor() {
        super("tdex_daemon.v2.TradeStatusInfo", [
            { no: 1, name: "status", kind: "enum", T: () => ["tdex_daemon.v2.TradeStatus", TradeStatus] },
            { no: 2, name: "failed", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TradeStatusInfo>): TradeStatusInfo {
        const message = { status: 0, failed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradeStatusInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeStatusInfo): TradeStatusInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.TradeStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* bool failed */ 2:
                    message.failed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeStatusInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.TradeStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* bool failed = 2; */
        if (message.failed !== false)
            writer.tag(2, WireType.Varint).bool(message.failed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.TradeStatusInfo
 */
export const TradeStatusInfo = new TradeStatusInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapInfo$Type extends MessageType<SwapInfo> {
    constructor() {
        super("tdex_daemon.v2.SwapInfo", [
            { no: 1, name: "amount_p", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "asset_p", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount_r", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "asset_r", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SwapInfo>): SwapInfo {
        const message = { amountP: 0, assetP: "", amountR: 0, assetR: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwapInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapInfo): SwapInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 amount_p */ 1:
                    message.amountP = reader.uint64().toNumber();
                    break;
                case /* string asset_p */ 2:
                    message.assetP = reader.string();
                    break;
                case /* uint64 amount_r */ 3:
                    message.amountR = reader.uint64().toNumber();
                    break;
                case /* string asset_r */ 4:
                    message.assetR = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 amount_p = 1; */
        if (message.amountP !== 0)
            writer.tag(1, WireType.Varint).uint64(message.amountP);
        /* string asset_p = 2; */
        if (message.assetP !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.assetP);
        /* uint64 amount_r = 3; */
        if (message.amountR !== 0)
            writer.tag(3, WireType.Varint).uint64(message.amountR);
        /* string asset_r = 4; */
        if (message.assetR !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.assetR);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.SwapInfo
 */
export const SwapInfo = new SwapInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SwapFailInfo$Type extends MessageType<SwapFailInfo> {
    constructor() {
        super("tdex_daemon.v2.SwapFailInfo", [
            { no: 1, name: "failure_code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "failure_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SwapFailInfo>): SwapFailInfo {
        const message = { failureCode: 0, failureMessage: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SwapFailInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SwapFailInfo): SwapFailInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 failure_code */ 1:
                    message.failureCode = reader.uint32();
                    break;
                case /* string failure_message */ 2:
                    message.failureMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SwapFailInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 failure_code = 1; */
        if (message.failureCode !== 0)
            writer.tag(1, WireType.Varint).uint32(message.failureCode);
        /* string failure_message = 2; */
        if (message.failureMessage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.failureMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.SwapFailInfo
 */
export const SwapFailInfo = new SwapFailInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradeInfo$Type extends MessageType<TradeInfo> {
    constructor() {
        super("tdex_daemon.v2.TradeInfo", [
            { no: 1, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "status", kind: "message", T: () => TradeStatusInfo },
            { no: 3, name: "swap_info", kind: "message", T: () => SwapInfo },
            { no: 4, name: "fail_info", kind: "message", T: () => SwapFailInfo },
            { no: 5, name: "market_with_fee", kind: "message", T: () => MarketWithFee },
            { no: 6, name: "price", kind: "message", T: () => Price },
            { no: 7, name: "request_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "accept_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 9, name: "complete_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 10, name: "settle_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 11, name: "expiry_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 12, name: "request_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "accept_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 14, name: "complete_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "settle_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 16, name: "expiry_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TradeInfo>): TradeInfo {
        const message = { tradeId: "", requestTimestamp: 0, acceptTimestamp: 0, completeTimestamp: 0, settleTimestamp: 0, expiryTimestamp: 0, requestDate: "", acceptDate: "", completeDate: "", settleDate: "", expiryDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TradeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradeInfo): TradeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_id */ 1:
                    message.tradeId = reader.string();
                    break;
                case /* tdex_daemon.v2.TradeStatusInfo status */ 2:
                    message.status = TradeStatusInfo.internalBinaryRead(reader, reader.uint32(), options, message.status);
                    break;
                case /* tdex_daemon.v2.SwapInfo swap_info */ 3:
                    message.swapInfo = SwapInfo.internalBinaryRead(reader, reader.uint32(), options, message.swapInfo);
                    break;
                case /* tdex_daemon.v2.SwapFailInfo fail_info */ 4:
                    message.failInfo = SwapFailInfo.internalBinaryRead(reader, reader.uint32(), options, message.failInfo);
                    break;
                case /* tdex.v1.MarketWithFee market_with_fee */ 5:
                    message.marketWithFee = MarketWithFee.internalBinaryRead(reader, reader.uint32(), options, message.marketWithFee);
                    break;
                case /* tdex.v1.Price price */ 6:
                    message.price = Price.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* int64 request_timestamp */ 7:
                    message.requestTimestamp = reader.int64().toNumber();
                    break;
                case /* int64 accept_timestamp */ 8:
                    message.acceptTimestamp = reader.int64().toNumber();
                    break;
                case /* int64 complete_timestamp */ 9:
                    message.completeTimestamp = reader.int64().toNumber();
                    break;
                case /* int64 settle_timestamp */ 10:
                    message.settleTimestamp = reader.int64().toNumber();
                    break;
                case /* int64 expiry_timestamp */ 11:
                    message.expiryTimestamp = reader.int64().toNumber();
                    break;
                case /* string request_date */ 12:
                    message.requestDate = reader.string();
                    break;
                case /* string accept_date */ 13:
                    message.acceptDate = reader.string();
                    break;
                case /* string complete_date */ 14:
                    message.completeDate = reader.string();
                    break;
                case /* string settle_date */ 15:
                    message.settleDate = reader.string();
                    break;
                case /* string expiry_date */ 16:
                    message.expiryDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TradeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_id = 1; */
        if (message.tradeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeId);
        /* tdex_daemon.v2.TradeStatusInfo status = 2; */
        if (message.status)
            TradeStatusInfo.internalBinaryWrite(message.status, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.SwapInfo swap_info = 3; */
        if (message.swapInfo)
            SwapInfo.internalBinaryWrite(message.swapInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.SwapFailInfo fail_info = 4; */
        if (message.failInfo)
            SwapFailInfo.internalBinaryWrite(message.failInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.MarketWithFee market_with_fee = 5; */
        if (message.marketWithFee)
            MarketWithFee.internalBinaryWrite(message.marketWithFee, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Price price = 6; */
        if (message.price)
            Price.internalBinaryWrite(message.price, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* int64 request_timestamp = 7; */
        if (message.requestTimestamp !== 0)
            writer.tag(7, WireType.Varint).int64(message.requestTimestamp);
        /* int64 accept_timestamp = 8; */
        if (message.acceptTimestamp !== 0)
            writer.tag(8, WireType.Varint).int64(message.acceptTimestamp);
        /* int64 complete_timestamp = 9; */
        if (message.completeTimestamp !== 0)
            writer.tag(9, WireType.Varint).int64(message.completeTimestamp);
        /* int64 settle_timestamp = 10; */
        if (message.settleTimestamp !== 0)
            writer.tag(10, WireType.Varint).int64(message.settleTimestamp);
        /* int64 expiry_timestamp = 11; */
        if (message.expiryTimestamp !== 0)
            writer.tag(11, WireType.Varint).int64(message.expiryTimestamp);
        /* string request_date = 12; */
        if (message.requestDate !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.requestDate);
        /* string accept_date = 13; */
        if (message.acceptDate !== "")
            writer.tag(13, WireType.LengthDelimited).string(message.acceptDate);
        /* string complete_date = 14; */
        if (message.completeDate !== "")
            writer.tag(14, WireType.LengthDelimited).string(message.completeDate);
        /* string settle_date = 15; */
        if (message.settleDate !== "")
            writer.tag(15, WireType.LengthDelimited).string(message.settleDate);
        /* string expiry_date = 16; */
        if (message.expiryDate !== "")
            writer.tag(16, WireType.LengthDelimited).string(message.expiryDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.TradeInfo
 */
export const TradeInfo = new TradeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeInfo$Type extends MessageType<FeeInfo> {
    constructor() {
        super("tdex_daemon.v2.FeeInfo", [
            { no: 1, name: "trade_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "basis_point", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "percentage_fee_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "fixed_fee_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "market_price", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "request_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeeInfo>): FeeInfo {
        const message = { tradeId: "", basisPoint: 0, asset: "", percentageFeeAmount: 0, fixedFeeAmount: 0, marketPrice: 0, requestDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeInfo): FeeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string trade_id */ 1:
                    message.tradeId = reader.string();
                    break;
                case /* int64 basis_point */ 2:
                    message.basisPoint = reader.int64().toNumber();
                    break;
                case /* string asset */ 3:
                    message.asset = reader.string();
                    break;
                case /* uint64 percentage_fee_amount */ 4:
                    message.percentageFeeAmount = reader.uint64().toNumber();
                    break;
                case /* uint64 fixed_fee_amount */ 5:
                    message.fixedFeeAmount = reader.uint64().toNumber();
                    break;
                case /* double market_price */ 6:
                    message.marketPrice = reader.double();
                    break;
                case /* string request_date */ 7:
                    message.requestDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string trade_id = 1; */
        if (message.tradeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.tradeId);
        /* int64 basis_point = 2; */
        if (message.basisPoint !== 0)
            writer.tag(2, WireType.Varint).int64(message.basisPoint);
        /* string asset = 3; */
        if (message.asset !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.asset);
        /* uint64 percentage_fee_amount = 4; */
        if (message.percentageFeeAmount !== 0)
            writer.tag(4, WireType.Varint).uint64(message.percentageFeeAmount);
        /* uint64 fixed_fee_amount = 5; */
        if (message.fixedFeeAmount !== 0)
            writer.tag(5, WireType.Varint).uint64(message.fixedFeeAmount);
        /* double market_price = 6; */
        if (message.marketPrice !== 0)
            writer.tag(6, WireType.Bit64).double(message.marketPrice);
        /* string request_date = 7; */
        if (message.requestDate !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.requestDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.FeeInfo
 */
export const FeeInfo = new FeeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Balance$Type extends MessageType<Balance> {
    constructor() {
        super("tdex_daemon.v2.Balance", [
            { no: 1, name: "confirmed_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "unconfirmed_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "locked_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "total_balance", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<Balance>): Balance {
        const message = { confirmedBalance: 0, unconfirmedBalance: 0, lockedBalance: 0, totalBalance: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Balance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Balance): Balance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 confirmed_balance */ 1:
                    message.confirmedBalance = reader.uint64().toNumber();
                    break;
                case /* uint64 unconfirmed_balance */ 2:
                    message.unconfirmedBalance = reader.uint64().toNumber();
                    break;
                case /* uint64 locked_balance */ 3:
                    message.lockedBalance = reader.uint64().toNumber();
                    break;
                case /* uint64 total_balance */ 4:
                    message.totalBalance = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Balance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 confirmed_balance = 1; */
        if (message.confirmedBalance !== 0)
            writer.tag(1, WireType.Varint).uint64(message.confirmedBalance);
        /* uint64 unconfirmed_balance = 2; */
        if (message.unconfirmedBalance !== 0)
            writer.tag(2, WireType.Varint).uint64(message.unconfirmedBalance);
        /* uint64 locked_balance = 3; */
        if (message.lockedBalance !== 0)
            writer.tag(3, WireType.Varint).uint64(message.lockedBalance);
        /* uint64 total_balance = 4; */
        if (message.totalBalance !== 0)
            writer.tag(4, WireType.Varint).uint64(message.totalBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.Balance
 */
export const Balance = new Balance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TxOutput$Type extends MessageType<TxOutput> {
    constructor() {
        super("tdex_daemon.v2.TxOutput", [
            { no: 1, name: "asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "script", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "blinding_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TxOutput>): TxOutput {
        const message = { asset: "", amount: 0, script: "", blindingKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TxOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TxOutput): TxOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string asset */ 1:
                    message.asset = reader.string();
                    break;
                case /* uint64 amount */ 2:
                    message.amount = reader.uint64().toNumber();
                    break;
                case /* string script */ 3:
                    message.script = reader.string();
                    break;
                case /* string blinding_key */ 4:
                    message.blindingKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TxOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string asset = 1; */
        if (message.asset !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.asset);
        /* uint64 amount = 2; */
        if (message.amount !== 0)
            writer.tag(2, WireType.Varint).uint64(message.amount);
        /* string script = 3; */
        if (message.script !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.script);
        /* string blinding_key = 4; */
        if (message.blindingKey !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.blindingKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.TxOutput
 */
export const TxOutput = new TxOutput$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Outpoint$Type extends MessageType<Outpoint> {
    constructor() {
        super("tdex_daemon.v2.Outpoint", [
            { no: 1, name: "hash", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "index", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Outpoint>): Outpoint {
        const message = { hash: "", index: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Outpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Outpoint): Outpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string hash */ 1:
                    message.hash = reader.string();
                    break;
                case /* uint32 index */ 2:
                    message.index = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Outpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string hash = 1; */
        if (message.hash !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.hash);
        /* uint32 index = 2; */
        if (message.index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.Outpoint
 */
export const Outpoint = new Outpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WebhookInfo$Type extends MessageType<WebhookInfo> {
    constructor() {
        super("tdex_daemon.v2.WebhookInfo", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "is_secured", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "action_type", kind: "enum", T: () => ["tdex_daemon.v2.ActionType", ActionType] }
        ]);
    }
    create(value?: PartialMessage<WebhookInfo>): WebhookInfo {
        const message = { id: "", endpoint: "", isSecured: false, actionType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WebhookInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WebhookInfo): WebhookInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string endpoint */ 2:
                    message.endpoint = reader.string();
                    break;
                case /* bool is_secured */ 3:
                    message.isSecured = reader.bool();
                    break;
                case /* tdex_daemon.v2.ActionType action_type */ 4:
                    message.actionType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WebhookInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string endpoint = 2; */
        if (message.endpoint !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endpoint);
        /* bool is_secured = 3; */
        if (message.isSecured !== false)
            writer.tag(3, WireType.Varint).bool(message.isSecured);
        /* tdex_daemon.v2.ActionType action_type = 4; */
        if (message.actionType !== 0)
            writer.tag(4, WireType.Varint).int32(message.actionType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WebhookInfo
 */
export const WebhookInfo = new WebhookInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super("tdex_daemon.v2.Transaction", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "total_amount_per_asset", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ } },
            { no: 3, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = { txid: "", totalAmountPerAsset: {}, timestamp: 0, date: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Transaction): Transaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                case /* map<string, uint64> total_amount_per_asset */ 2:
                    this.binaryReadMap2(message.totalAmountPerAsset, reader, options);
                    break;
                case /* int64 timestamp */ 3:
                    message.timestamp = reader.int64().toNumber();
                    break;
                case /* string date */ 4:
                    message.date = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Transaction["totalAmountPerAsset"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Transaction["totalAmountPerAsset"] | undefined, val: Transaction["totalAmountPerAsset"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.uint64().toNumber();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v2.Transaction.total_amount_per_asset");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Transaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        /* map<string, uint64> total_amount_per_asset = 2; */
        for (let k of Object.keys(message.totalAmountPerAsset))
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).uint64(message.totalAmountPerAsset[k]).join();
        /* int64 timestamp = 3; */
        if (message.timestamp !== 0)
            writer.tag(3, WireType.Varint).int64(message.timestamp);
        /* string date = 4; */
        if (message.date !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.date);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.Transaction
 */
export const Transaction = new Transaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Page$Type extends MessageType<Page> {
    constructor() {
        super("tdex_daemon.v2.Page", [
            { no: 1, name: "number", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "size", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<Page>): Page {
        const message = { number: 0, size: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Page>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Page): Page {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 number */ 1:
                    message.number = reader.int64().toNumber();
                    break;
                case /* int64 size */ 2:
                    message.size = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Page, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 number = 1; */
        if (message.number !== 0)
            writer.tag(1, WireType.Varint).int64(message.number);
        /* int64 size = 2; */
        if (message.size !== 0)
            writer.tag(2, WireType.Varint).int64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.Page
 */
export const Page = new Page$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketReport$Type extends MessageType<MarketReport> {
    constructor() {
        super("tdex_daemon.v2.MarketReport", [
            { no: 1, name: "total_collected_fees", kind: "message", T: () => MarketCollectedFees },
            { no: 2, name: "total_volume", kind: "message", T: () => MarketVolume },
            { no: 3, name: "volumes_per_frame", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketVolume }
        ]);
    }
    create(value?: PartialMessage<MarketReport>): MarketReport {
        const message = { volumesPerFrame: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketReport>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketReport): MarketReport {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.MarketCollectedFees total_collected_fees */ 1:
                    message.totalCollectedFees = MarketCollectedFees.internalBinaryRead(reader, reader.uint32(), options, message.totalCollectedFees);
                    break;
                case /* tdex_daemon.v2.MarketVolume total_volume */ 2:
                    message.totalVolume = MarketVolume.internalBinaryRead(reader, reader.uint32(), options, message.totalVolume);
                    break;
                case /* repeated tdex_daemon.v2.MarketVolume volumes_per_frame */ 3:
                    message.volumesPerFrame.push(MarketVolume.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketReport, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.MarketCollectedFees total_collected_fees = 1; */
        if (message.totalCollectedFees)
            MarketCollectedFees.internalBinaryWrite(message.totalCollectedFees, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.MarketVolume total_volume = 2; */
        if (message.totalVolume)
            MarketVolume.internalBinaryWrite(message.totalVolume, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v2.MarketVolume volumes_per_frame = 3; */
        for (let i = 0; i < message.volumesPerFrame.length; i++)
            MarketVolume.internalBinaryWrite(message.volumesPerFrame[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.MarketReport
 */
export const MarketReport = new MarketReport$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketCollectedFees$Type extends MessageType<MarketCollectedFees> {
    constructor() {
        super("tdex_daemon.v2.MarketCollectedFees", [
            { no: 1, name: "base_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "quote_amount", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "fees_per_trade", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FeeInfo },
            { no: 4, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketCollectedFees>): MarketCollectedFees {
        const message = { baseAmount: 0, quoteAmount: 0, feesPerTrade: [], startDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketCollectedFees>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketCollectedFees): MarketCollectedFees {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 base_amount */ 1:
                    message.baseAmount = reader.uint64().toNumber();
                    break;
                case /* uint64 quote_amount */ 2:
                    message.quoteAmount = reader.uint64().toNumber();
                    break;
                case /* repeated tdex_daemon.v2.FeeInfo fees_per_trade */ 3:
                    message.feesPerTrade.push(FeeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string start_date */ 4:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 5:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketCollectedFees, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 base_amount = 1; */
        if (message.baseAmount !== 0)
            writer.tag(1, WireType.Varint).uint64(message.baseAmount);
        /* uint64 quote_amount = 2; */
        if (message.quoteAmount !== 0)
            writer.tag(2, WireType.Varint).uint64(message.quoteAmount);
        /* repeated tdex_daemon.v2.FeeInfo fees_per_trade = 3; */
        for (let i = 0; i < message.feesPerTrade.length; i++)
            FeeInfo.internalBinaryWrite(message.feesPerTrade[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string start_date = 4; */
        if (message.startDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 5; */
        if (message.endDate !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.MarketCollectedFees
 */
export const MarketCollectedFees = new MarketCollectedFees$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketVolume$Type extends MessageType<MarketVolume> {
    constructor() {
        super("tdex_daemon.v2.MarketVolume", [
            { no: 1, name: "base_volume", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "quote_volume", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketVolume>): MarketVolume {
        const message = { baseVolume: 0, quoteVolume: 0, startDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketVolume>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketVolume): MarketVolume {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 base_volume */ 1:
                    message.baseVolume = reader.uint64().toNumber();
                    break;
                case /* uint64 quote_volume */ 2:
                    message.quoteVolume = reader.uint64().toNumber();
                    break;
                case /* string start_date */ 3:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 4:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketVolume, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 base_volume = 1; */
        if (message.baseVolume !== 0)
            writer.tag(1, WireType.Varint).uint64(message.baseVolume);
        /* uint64 quote_volume = 2; */
        if (message.quoteVolume !== 0)
            writer.tag(2, WireType.Varint).uint64(message.quoteVolume);
        /* string start_date = 3; */
        if (message.startDate !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 4; */
        if (message.endDate !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.MarketVolume
 */
export const MarketVolume = new MarketVolume$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TimeRange$Type extends MessageType<TimeRange> {
    constructor() {
        super("tdex_daemon.v2.TimeRange", [
            { no: 1, name: "predefined_period", kind: "enum", T: () => ["tdex_daemon.v2.PredefinedPeriod", PredefinedPeriod] },
            { no: 2, name: "custom_period", kind: "message", T: () => CustomPeriod }
        ]);
    }
    create(value?: PartialMessage<TimeRange>): TimeRange {
        const message = { predefinedPeriod: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TimeRange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TimeRange): TimeRange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.PredefinedPeriod predefined_period */ 1:
                    message.predefinedPeriod = reader.int32();
                    break;
                case /* tdex_daemon.v2.CustomPeriod custom_period */ 2:
                    message.customPeriod = CustomPeriod.internalBinaryRead(reader, reader.uint32(), options, message.customPeriod);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TimeRange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.PredefinedPeriod predefined_period = 1; */
        if (message.predefinedPeriod !== 0)
            writer.tag(1, WireType.Varint).int32(message.predefinedPeriod);
        /* tdex_daemon.v2.CustomPeriod custom_period = 2; */
        if (message.customPeriod)
            CustomPeriod.internalBinaryWrite(message.customPeriod, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.TimeRange
 */
export const TimeRange = new TimeRange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CustomPeriod$Type extends MessageType<CustomPeriod> {
    constructor() {
        super("tdex_daemon.v2.CustomPeriod", [
            { no: 1, name: "start_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "end_date", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CustomPeriod>): CustomPeriod {
        const message = { startDate: "", endDate: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CustomPeriod>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CustomPeriod): CustomPeriod {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string start_date */ 1:
                    message.startDate = reader.string();
                    break;
                case /* string end_date */ 2:
                    message.endDate = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CustomPeriod, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string start_date = 1; */
        if (message.startDate !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.startDate);
        /* string end_date = 2; */
        if (message.endDate !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.endDate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.CustomPeriod
 */
export const CustomPeriod = new CustomPeriod$Type();
