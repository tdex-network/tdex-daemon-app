/* eslint-disable */
// @generated by protobuf-ts 2.8.2 with parameter add_pb_suffix,eslint_disable,ts_nocheck,keep_enum_prefix,long_type_number
// @generated from protobuf file "tdex-daemon/v2/operator.proto" (package "tdex_daemon.v2", syntax proto3)
// tslint:disable
// @ts-nocheck
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Transaction } from "./types_pb";
import { WebhookInfo } from "./types_pb";
import { ActionType } from "./types_pb";
import { UtxoInfo } from "./types_pb";
import { TradeInfo } from "./types_pb";
import { Page } from "./types_pb";
import { StrategyType } from "./types_pb";
import { Price } from "../../tdex/v1/types_pb";
import { Fixed } from "../../tdex/v1/types_pb";
import { MarketWithFee } from "../../tdex/v1/types_pb";
import { MarketReport } from "./types_pb";
import { TimeFrame } from "./types_pb";
import { TimeRange } from "./types_pb";
import { MarketInfo } from "./types_pb";
import { Market } from "../../tdex/v1/types_pb";
import { TxOutput } from "./types_pb";
import { Balance } from "./types_pb";
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveFeeAddressesRequest
 */
export interface DeriveFeeAddressesRequest {
    /**
     * The number of addresses to generate.
     *
     * @generated from protobuf field: int64 num_of_addresses = 1 [jstype = JS_NUMBER];
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveFeeAddressesResponse
 */
export interface DeriveFeeAddressesResponse {
    /**
     * The list of new confidential addresses.
     *
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListFeeAddressesRequest
 */
export interface ListFeeAddressesRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListFeeAddressesResponse
 */
export interface ListFeeAddressesResponse {
    /**
     * The list of derived confidential addresses.
     *
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetFeeBalanceRequest
 */
export interface GetFeeBalanceRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetFeeBalanceResponse
 */
export interface GetFeeBalanceResponse {
    /**
     * @generated from protobuf field: tdex_daemon.v2.Balance balance = 1;
     */
    balance?: Balance;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawFeeRequest
 */
export interface WithdrawFeeRequest {
    /**
     * List of receivers.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.TxOutput outputs = 1;
     */
    outputs: TxOutput[];
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
    /**
     * The password that unlocks the internal wallet.
     *
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawFeeResponse
 */
export interface WithdrawFeeResponse {
    /**
     * The transaction hash in mempool/blockchain.
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.NewMarketRequest
 */
export interface NewMarketRequest {
    /**
     * The asset pair for which creating a new account in the daemon's wallet.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v2.NewMarketResponse
 */
export interface NewMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetMarketInfoRequest
 */
export interface GetMarketInfoRequest {
    /**
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetMarketInfoResponse
 */
export interface GetMarketInfoResponse {
    /**
     * @generated from protobuf field: tdex_daemon.v2.MarketInfo info = 1;
     */
    info?: MarketInfo;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveMarketAddressesRequest
 */
export interface DeriveMarketAddressesRequest {
    /**
     * The market for which deriving new addresses.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The number of addresses to generate.
     *
     * @generated from protobuf field: int64 num_of_addresses = 2 [jstype = JS_NUMBER];
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveMarketAddressesResponse
 */
export interface DeriveMarketAddressesResponse {
    /**
     * The list of new confidential addresses.
     *
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListMarketAddressesRequest
 */
export interface ListMarketAddressesRequest {
    /**
     * The Market for which listing all derived addresses.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListMarketAddressesResponse
 */
export interface ListMarketAddressesResponse {
    /**
     * The list of derived confidential addresses.
     *
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.OpenMarketRequest
 */
export interface OpenMarketRequest {
    /**
     * The market to be made tradable.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v2.OpenMarketResponse
 */
export interface OpenMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.CloseMarketRequest
 */
export interface CloseMarketRequest {
    /**
     * The market to be made not tradable.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v2.CloseMarketResponse
 */
export interface CloseMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.DropMarketRequest
 */
export interface DropMarketRequest {
    /**
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DropMarketResponse
 */
export interface DropMarketResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawMarketRequest
 */
export interface WithdrawMarketRequest {
    /**
     * The market from which funds should be withdrawn.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * List of receivers.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.TxOutput outputs = 2;
     */
    outputs: TxOutput[];
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 3;
     */
    millisatsPerByte: number;
    /**
     * The password that unlocks the internal wallet.
     *
     * @generated from protobuf field: string password = 4;
     */
    password: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawMarketResponse
 */
export interface WithdrawMarketResponse {
    /**
     * The transaction hash in mempool/blockchain.
     *
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetMarketReportRequest
 */
export interface GetMarketReportRequest {
    /**
     * The market for which returning the report of collected fees.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * time_range fetch market report from time range
     *
     * @generated from protobuf field: tdex_daemon.v2.TimeRange time_range = 2;
     */
    timeRange?: TimeRange;
    /**
     * used to group volume by time_frame for the specified time_range
     *
     * @generated from protobuf field: tdex_daemon.v2.TimeFrame time_frame = 3;
     */
    timeFrame: TimeFrame;
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetMarketReportResponse
 */
export interface GetMarketReportResponse {
    /**
     * MarketReport holds info about volume and collected fees
     *
     * @generated from protobuf field: tdex_daemon.v2.MarketReport report = 1;
     */
    report?: MarketReport;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketPercentageFeeRequest
 */
export interface UpdateMarketPercentageFeeRequest {
    /**
     * The market for which updating the percentage fee.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new percentage fee expresses in basis point.
     *
     * @generated from protobuf field: uint32 basis_point = 2 [jstype = JS_NUMBER];
     */
    basisPoint: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketPercentageFeeResponse
 */
export interface UpdateMarketPercentageFeeResponse {
    /**
     * The market with updated fees.
     *
     * @generated from protobuf field: tdex.v1.MarketWithFee market_with_fee = 1;
     */
    marketWithFee?: MarketWithFee;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketFixedFeeRequest
 */
export interface UpdateMarketFixedFeeRequest {
    /**
     * The market for which updating the fixed fee.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new fixed fee for base and quote asset.
     *
     * @generated from protobuf field: tdex.v1.Fixed fixed = 2;
     */
    fixed?: Fixed;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketFixedFeeResponse
 */
export interface UpdateMarketFixedFeeResponse {
    /**
     * The market with updated fees.
     *
     * @generated from protobuf field: tdex.v1.MarketWithFee market_with_fee = 1;
     */
    marketWithFee?: MarketWithFee;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketPriceRequest
 */
export interface UpdateMarketPriceRequest {
    /**
     * The arket for which updating the price.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new price for base and quote asset.
     *
     * @generated from protobuf field: tdex.v1.Price price = 2;
     */
    price?: Price;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketPriceResponse
 */
export interface UpdateMarketPriceResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketStrategyRequest
 */
export interface UpdateMarketStrategyRequest {
    /**
     * The market for which changing the strategy.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The new making strategy to use.
     *
     * @generated from protobuf field: tdex_daemon.v2.StrategyType strategy_type = 2;
     */
    strategyType: StrategyType;
    /**
     * The JSON string representing additional metadata about the new strategy.
     *
     * @generated from protobuf field: string metadata = 3;
     */
    metadata: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.UpdateMarketStrategyResponse
 */
export interface UpdateMarketStrategyResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveFeeFragmenterAddressesRequest
 */
export interface DeriveFeeFragmenterAddressesRequest {
    /**
     * @generated from protobuf field: int64 num_of_addresses = 1 [jstype = JS_NUMBER];
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveFeeFragmenterAddressesResponse
 */
export interface DeriveFeeFragmenterAddressesResponse {
    /**
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListFeeFragmenterAddressesRequest
 */
export interface ListFeeFragmenterAddressesRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListFeeFragmenterAddressesResponse
 */
export interface ListFeeFragmenterAddressesResponse {
    /**
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetFeeFragmenterBalanceRequest
 */
export interface GetFeeFragmenterBalanceRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetFeeFragmenterBalanceResponse
 */
export interface GetFeeFragmenterBalanceResponse {
    /**
     * Account balance grouped by asset.
     *
     * @generated from protobuf field: map<string, tdex_daemon.v2.Balance> balance = 1;
     */
    balance: {
        [key: string]: Balance;
    };
}
/**
 * @generated from protobuf message tdex_daemon.v2.FeeFragmenterSplitFundsRequest
 */
export interface FeeFragmenterSplitFundsRequest {
    /**
     * The max number of fragments the fragmenter can generate when splitting
     * its funds.
     *
     * @generated from protobuf field: uint32 max_fragments = 1;
     */
    maxFragments: number;
    /**
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.FeeFragmenterSplitFundsResponse
 */
export interface FeeFragmenterSplitFundsResponse {
    /**
     * A sequence of string messages returned during the process.
     *
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawFeeFragmenterRequest
 */
export interface WithdrawFeeFragmenterRequest {
    /**
     * List of receivers.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.TxOutput outputs = 1;
     */
    outputs: TxOutput[];
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
    /**
     * The password that unlocks the internal wallet.
     *
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawFeeFragmenterResponse
 */
export interface WithdrawFeeFragmenterResponse {
    /**
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveMarketFragmenterAddressesRequest
 */
export interface DeriveMarketFragmenterAddressesRequest {
    /**
     * @generated from protobuf field: int64 num_of_addresses = 1 [jstype = JS_NUMBER];
     */
    numOfAddresses: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.DeriveMarketFragmenterAddressesResponse
 */
export interface DeriveMarketFragmenterAddressesResponse {
    /**
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListMarketFragmenterAddressesRequest
 */
export interface ListMarketFragmenterAddressesRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListMarketFragmenterAddressesResponse
 */
export interface ListMarketFragmenterAddressesResponse {
    /**
     * @generated from protobuf field: repeated string addresses = 1;
     */
    addresses: string[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetMarketFragmenterBalanceRequest
 */
export interface GetMarketFragmenterBalanceRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.GetMarketFragmenterBalanceResponse
 */
export interface GetMarketFragmenterBalanceResponse {
    /**
     * Account balance grouped by asset
     *
     * @generated from protobuf field: map<string, tdex_daemon.v2.Balance> balance = 1;
     */
    balance: {
        [key: string]: Balance;
    };
}
/**
 * @generated from protobuf message tdex_daemon.v2.MarketFragmenterSplitFundsRequest
 */
export interface MarketFragmenterSplitFundsRequest {
    /**
     * The market to which to deposit the fragmented funds owned by the market
     * fragmenter.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
}
/**
 * @generated from protobuf message tdex_daemon.v2.MarketFragmenterSplitFundsResponse
 */
export interface MarketFragmenterSplitFundsResponse {
    /**
     * A sequence of string messages returned during the process.
     *
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawMarketFragmenterRequest
 */
export interface WithdrawMarketFragmenterRequest {
    /**
     * List of receivers.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.TxOutput outputs = 1;
     */
    outputs: TxOutput[];
    /**
     * The number of millisatoshis per byte that should be paid for network fees.
     *
     * @generated from protobuf field: uint64 millisats_per_byte = 2;
     */
    millisatsPerByte: number;
    /**
     * The password that unlocks the internal wallet.
     *
     * @generated from protobuf field: string password = 3;
     */
    password: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.WithdrawMarketFragmenterResponse
 */
export interface WithdrawMarketFragmenterResponse {
    /**
     * @generated from protobuf field: string txid = 1;
     */
    txid: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListMarketsRequest
 */
export interface ListMarketsRequest {
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListMarketsResponse
 */
export interface ListMarketsResponse {
    /**
     * The list of info about all the created markets.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.MarketInfo markets = 1;
     */
    markets: MarketInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListTradesRequest
 */
export interface ListTradesRequest {
    /**
     * Market for which listing trades.
     *
     * @generated from protobuf field: tdex.v1.Market market = 1;
     */
    market?: Market;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v2.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListTradesResponse
 */
export interface ListTradesResponse {
    /**
     * The list of info about all trades or all trades for a market depending on
     * the request.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.TradeInfo trades = 1;
     */
    trades: TradeInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListUtxosRequest
 */
export interface ListUtxosRequest {
    /**
     * Name of the account for which listing utxos.
     *
     * @generated from protobuf field: string account_name = 1;
     */
    accountName: string;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v2.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListUtxosResponse
 */
export interface ListUtxosResponse {
    /**
     * The list of all spendable utxos.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.UtxoInfo spendable_utxos = 1;
     */
    spendableUtxos: UtxoInfo[];
    /**
     * The list of all locked utxos.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.UtxoInfo locked_utxos = 2;
     */
    lockedUtxos: UtxoInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.AddWebhookRequest
 */
export interface AddWebhookRequest {
    /**
     * The endpoint of the external service to reach.
     *
     * @generated from protobuf field: string endpoint = 1;
     */
    endpoint: string;
    /**
     * The type of action for which the webhook should be registered.
     *
     * @generated from protobuf field: tdex_daemon.v2.ActionType action = 2;
     */
    action: ActionType;
    /**
     * The secret to use for signign a JWT token for an authenticated request
     * to the external service.
     *
     * @generated from protobuf field: string secret = 3;
     */
    secret: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.AddWebhookResponse
 */
export interface AddWebhookResponse {
    /**
     * The id of the new webhook.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.RemoveWebhookRequest
 */
export interface RemoveWebhookRequest {
    /**
     * The id of the webhook to remove.
     *
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message tdex_daemon.v2.RemoveWebhookResponse
 */
export interface RemoveWebhookResponse {
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListWebhooksRequest
 */
export interface ListWebhooksRequest {
    /**
     * The action for which filtering the list of webhooks.
     *
     * @generated from protobuf field: tdex_daemon.v2.ActionType action = 1;
     */
    action: ActionType;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListWebhooksResponse
 */
export interface ListWebhooksResponse {
    /**
     * The list of info about the webhooks regitered for an action.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.WebhookInfo webhook_info = 1;
     */
    webhookInfo: WebhookInfo[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListDepositsRequest
 */
export interface ListDepositsRequest {
    /**
     * The name of the wallet account for which listing the deposits.
     *
     * @generated from protobuf field: string account_name = 1;
     */
    accountName: string;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v2.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListDepositsResponse
 */
export interface ListDepositsResponse {
    /**
     * The name of the wallet account.
     *
     * @generated from protobuf field: string account_name = 1;
     */
    accountName: string;
    /**
     * The list of info about the deposits.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.Transaction deposits = 2;
     */
    deposits: Transaction[];
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListWithdrawalsRequest
 */
export interface ListWithdrawalsRequest {
    /**
     * The name of the wallet account for which listing the withdrawals.
     *
     * @generated from protobuf field: string account_name = 1;
     */
    accountName: string;
    /**
     * The page for a paginated reply.
     *
     * @generated from protobuf field: tdex_daemon.v2.Page page = 2;
     */
    page?: Page;
}
/**
 * @generated from protobuf message tdex_daemon.v2.ListWithdrawalsResponse
 */
export interface ListWithdrawalsResponse {
    /**
     * The name of the wallet account.
     *
     * @generated from protobuf field: string account_name = 1;
     */
    accountName: string;
    /**
     * The list of info about the withdrawals.
     *
     * @generated from protobuf field: repeated tdex_daemon.v2.Transaction withdrawals = 2;
     */
    withdrawals: Transaction[];
}
// @generated message type with reflection information, may provide speed optimized methods
class DeriveFeeAddressesRequest$Type extends MessageType<DeriveFeeAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.DeriveFeeAddressesRequest", [
            { no: 1, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveFeeAddressesRequest>): DeriveFeeAddressesRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveFeeAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveFeeAddressesRequest): DeriveFeeAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_of_addresses = 1 [jstype = JS_NUMBER];*/ 1:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveFeeAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_of_addresses = 1 [jstype = JS_NUMBER]; */
        if (message.numOfAddresses !== 0)
            writer.tag(1, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveFeeAddressesRequest
 */
export const DeriveFeeAddressesRequest = new DeriveFeeAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveFeeAddressesResponse$Type extends MessageType<DeriveFeeAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.DeriveFeeAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveFeeAddressesResponse>): DeriveFeeAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveFeeAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveFeeAddressesResponse): DeriveFeeAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveFeeAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveFeeAddressesResponse
 */
export const DeriveFeeAddressesResponse = new DeriveFeeAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeAddressesRequest$Type extends MessageType<ListFeeAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.ListFeeAddressesRequest", []);
    }
    create(value?: PartialMessage<ListFeeAddressesRequest>): ListFeeAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeAddressesRequest): ListFeeAddressesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListFeeAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListFeeAddressesRequest
 */
export const ListFeeAddressesRequest = new ListFeeAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeAddressesResponse$Type extends MessageType<ListFeeAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.ListFeeAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListFeeAddressesResponse>): ListFeeAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeAddressesResponse): ListFeeAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFeeAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListFeeAddressesResponse
 */
export const ListFeeAddressesResponse = new ListFeeAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeBalanceRequest$Type extends MessageType<GetFeeBalanceRequest> {
    constructor() {
        super("tdex_daemon.v2.GetFeeBalanceRequest", []);
    }
    create(value?: PartialMessage<GetFeeBalanceRequest>): GetFeeBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeBalanceRequest): GetFeeBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFeeBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetFeeBalanceRequest
 */
export const GetFeeBalanceRequest = new GetFeeBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeBalanceResponse$Type extends MessageType<GetFeeBalanceResponse> {
    constructor() {
        super("tdex_daemon.v2.GetFeeBalanceResponse", [
            { no: 1, name: "balance", kind: "message", T: () => Balance }
        ]);
    }
    create(value?: PartialMessage<GetFeeBalanceResponse>): GetFeeBalanceResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeBalanceResponse): GetFeeBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.Balance balance */ 1:
                    message.balance = Balance.internalBinaryRead(reader, reader.uint32(), options, message.balance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFeeBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.Balance balance = 1; */
        if (message.balance)
            Balance.internalBinaryWrite(message.balance, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetFeeBalanceResponse
 */
export const GetFeeBalanceResponse = new GetFeeBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeRequest$Type extends MessageType<WithdrawFeeRequest> {
    constructor() {
        super("tdex_daemon.v2.WithdrawFeeRequest", [
            { no: 1, name: "outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TxOutput },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeRequest>): WithdrawFeeRequest {
        const message = { outputs: [], millisatsPerByte: 0, password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeRequest): WithdrawFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.TxOutput outputs */ 1:
                    message.outputs.push(TxOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.TxOutput outputs = 1; */
        for (let i = 0; i < message.outputs.length; i++)
            TxOutput.internalBinaryWrite(message.outputs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawFeeRequest
 */
export const WithdrawFeeRequest = new WithdrawFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeResponse$Type extends MessageType<WithdrawFeeResponse> {
    constructor() {
        super("tdex_daemon.v2.WithdrawFeeResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeResponse>): WithdrawFeeResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeResponse): WithdrawFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawFeeResponse
 */
export const WithdrawFeeResponse = new WithdrawFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewMarketRequest$Type extends MessageType<NewMarketRequest> {
    constructor() {
        super("tdex_daemon.v2.NewMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<NewMarketRequest>): NewMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewMarketRequest): NewMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.NewMarketRequest
 */
export const NewMarketRequest = new NewMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewMarketResponse$Type extends MessageType<NewMarketResponse> {
    constructor() {
        super("tdex_daemon.v2.NewMarketResponse", []);
    }
    create(value?: PartialMessage<NewMarketResponse>): NewMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewMarketResponse): NewMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: NewMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.NewMarketResponse
 */
export const NewMarketResponse = new NewMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketInfoRequest$Type extends MessageType<GetMarketInfoRequest> {
    constructor() {
        super("tdex_daemon.v2.GetMarketInfoRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<GetMarketInfoRequest>): GetMarketInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketInfoRequest): GetMarketInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetMarketInfoRequest
 */
export const GetMarketInfoRequest = new GetMarketInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketInfoResponse$Type extends MessageType<GetMarketInfoResponse> {
    constructor() {
        super("tdex_daemon.v2.GetMarketInfoResponse", [
            { no: 1, name: "info", kind: "message", T: () => MarketInfo }
        ]);
    }
    create(value?: PartialMessage<GetMarketInfoResponse>): GetMarketInfoResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketInfoResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketInfoResponse): GetMarketInfoResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.MarketInfo info */ 1:
                    message.info = MarketInfo.internalBinaryRead(reader, reader.uint32(), options, message.info);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketInfoResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.MarketInfo info = 1; */
        if (message.info)
            MarketInfo.internalBinaryWrite(message.info, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetMarketInfoResponse
 */
export const GetMarketInfoResponse = new GetMarketInfoResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveMarketAddressesRequest$Type extends MessageType<DeriveMarketAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.DeriveMarketAddressesRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveMarketAddressesRequest>): DeriveMarketAddressesRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveMarketAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveMarketAddressesRequest): DeriveMarketAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* int64 num_of_addresses = 2 [jstype = JS_NUMBER];*/ 2:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveMarketAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 num_of_addresses = 2 [jstype = JS_NUMBER]; */
        if (message.numOfAddresses !== 0)
            writer.tag(2, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveMarketAddressesRequest
 */
export const DeriveMarketAddressesRequest = new DeriveMarketAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveMarketAddressesResponse$Type extends MessageType<DeriveMarketAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.DeriveMarketAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveMarketAddressesResponse>): DeriveMarketAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveMarketAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveMarketAddressesResponse): DeriveMarketAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveMarketAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveMarketAddressesResponse
 */
export const DeriveMarketAddressesResponse = new DeriveMarketAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketAddressesRequest$Type extends MessageType<ListMarketAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.ListMarketAddressesRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<ListMarketAddressesRequest>): ListMarketAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketAddressesRequest): ListMarketAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListMarketAddressesRequest
 */
export const ListMarketAddressesRequest = new ListMarketAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketAddressesResponse$Type extends MessageType<ListMarketAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.ListMarketAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListMarketAddressesResponse>): ListMarketAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketAddressesResponse): ListMarketAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListMarketAddressesResponse
 */
export const ListMarketAddressesResponse = new ListMarketAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenMarketRequest$Type extends MessageType<OpenMarketRequest> {
    constructor() {
        super("tdex_daemon.v2.OpenMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<OpenMarketRequest>): OpenMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenMarketRequest): OpenMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.OpenMarketRequest
 */
export const OpenMarketRequest = new OpenMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OpenMarketResponse$Type extends MessageType<OpenMarketResponse> {
    constructor() {
        super("tdex_daemon.v2.OpenMarketResponse", []);
    }
    create(value?: PartialMessage<OpenMarketResponse>): OpenMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OpenMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenMarketResponse): OpenMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: OpenMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.OpenMarketResponse
 */
export const OpenMarketResponse = new OpenMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseMarketRequest$Type extends MessageType<CloseMarketRequest> {
    constructor() {
        super("tdex_daemon.v2.CloseMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<CloseMarketRequest>): CloseMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseMarketRequest): CloseMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.CloseMarketRequest
 */
export const CloseMarketRequest = new CloseMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseMarketResponse$Type extends MessageType<CloseMarketResponse> {
    constructor() {
        super("tdex_daemon.v2.CloseMarketResponse", []);
    }
    create(value?: PartialMessage<CloseMarketResponse>): CloseMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseMarketResponse): CloseMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CloseMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.CloseMarketResponse
 */
export const CloseMarketResponse = new CloseMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropMarketRequest$Type extends MessageType<DropMarketRequest> {
    constructor() {
        super("tdex_daemon.v2.DropMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market }
        ]);
    }
    create(value?: PartialMessage<DropMarketRequest>): DropMarketRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DropMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DropMarketRequest): DropMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DropMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DropMarketRequest
 */
export const DropMarketRequest = new DropMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DropMarketResponse$Type extends MessageType<DropMarketResponse> {
    constructor() {
        super("tdex_daemon.v2.DropMarketResponse", []);
    }
    create(value?: PartialMessage<DropMarketResponse>): DropMarketResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DropMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DropMarketResponse): DropMarketResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DropMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DropMarketResponse
 */
export const DropMarketResponse = new DropMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketRequest$Type extends MessageType<WithdrawMarketRequest> {
    constructor() {
        super("tdex_daemon.v2.WithdrawMarketRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TxOutput },
            { no: 3, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketRequest>): WithdrawMarketRequest {
        const message = { outputs: [], millisatsPerByte: 0, password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketRequest): WithdrawMarketRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* repeated tdex_daemon.v2.TxOutput outputs */ 2:
                    message.outputs.push(TxOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 millisats_per_byte */ 3:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                case /* string password */ 4:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v2.TxOutput outputs = 2; */
        for (let i = 0; i < message.outputs.length; i++)
            TxOutput.internalBinaryWrite(message.outputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint64 millisats_per_byte = 3; */
        if (message.millisatsPerByte !== 0)
            writer.tag(3, WireType.Varint).uint64(message.millisatsPerByte);
        /* string password = 4; */
        if (message.password !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawMarketRequest
 */
export const WithdrawMarketRequest = new WithdrawMarketRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketResponse$Type extends MessageType<WithdrawMarketResponse> {
    constructor() {
        super("tdex_daemon.v2.WithdrawMarketResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketResponse>): WithdrawMarketResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketResponse): WithdrawMarketResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawMarketResponse
 */
export const WithdrawMarketResponse = new WithdrawMarketResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketReportRequest$Type extends MessageType<GetMarketReportRequest> {
    constructor() {
        super("tdex_daemon.v2.GetMarketReportRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "time_range", kind: "message", T: () => TimeRange },
            { no: 3, name: "time_frame", kind: "enum", T: () => ["tdex_daemon.v2.TimeFrame", TimeFrame] }
        ]);
    }
    create(value?: PartialMessage<GetMarketReportRequest>): GetMarketReportRequest {
        const message = { timeFrame: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketReportRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketReportRequest): GetMarketReportRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v2.TimeRange time_range */ 2:
                    message.timeRange = TimeRange.internalBinaryRead(reader, reader.uint32(), options, message.timeRange);
                    break;
                case /* tdex_daemon.v2.TimeFrame time_frame */ 3:
                    message.timeFrame = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketReportRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.TimeRange time_range = 2; */
        if (message.timeRange)
            TimeRange.internalBinaryWrite(message.timeRange, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.TimeFrame time_frame = 3; */
        if (message.timeFrame !== 0)
            writer.tag(3, WireType.Varint).int32(message.timeFrame);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetMarketReportRequest
 */
export const GetMarketReportRequest = new GetMarketReportRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketReportResponse$Type extends MessageType<GetMarketReportResponse> {
    constructor() {
        super("tdex_daemon.v2.GetMarketReportResponse", [
            { no: 1, name: "report", kind: "message", T: () => MarketReport }
        ]);
    }
    create(value?: PartialMessage<GetMarketReportResponse>): GetMarketReportResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketReportResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketReportResponse): GetMarketReportResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.MarketReport report */ 1:
                    message.report = MarketReport.internalBinaryRead(reader, reader.uint32(), options, message.report);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMarketReportResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.MarketReport report = 1; */
        if (message.report)
            MarketReport.internalBinaryWrite(message.report, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetMarketReportResponse
 */
export const GetMarketReportResponse = new GetMarketReportResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPercentageFeeRequest$Type extends MessageType<UpdateMarketPercentageFeeRequest> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketPercentageFeeRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "basis_point", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketPercentageFeeRequest>): UpdateMarketPercentageFeeRequest {
        const message = { basisPoint: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPercentageFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPercentageFeeRequest): UpdateMarketPercentageFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* uint32 basis_point = 2 [jstype = JS_NUMBER];*/ 2:
                    message.basisPoint = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketPercentageFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 basis_point = 2 [jstype = JS_NUMBER]; */
        if (message.basisPoint !== 0)
            writer.tag(2, WireType.Varint).uint32(message.basisPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketPercentageFeeRequest
 */
export const UpdateMarketPercentageFeeRequest = new UpdateMarketPercentageFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPercentageFeeResponse$Type extends MessageType<UpdateMarketPercentageFeeResponse> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketPercentageFeeResponse", [
            { no: 1, name: "market_with_fee", kind: "message", T: () => MarketWithFee }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketPercentageFeeResponse>): UpdateMarketPercentageFeeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPercentageFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPercentageFeeResponse): UpdateMarketPercentageFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.MarketWithFee market_with_fee */ 1:
                    message.marketWithFee = MarketWithFee.internalBinaryRead(reader, reader.uint32(), options, message.marketWithFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketPercentageFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.MarketWithFee market_with_fee = 1; */
        if (message.marketWithFee)
            MarketWithFee.internalBinaryWrite(message.marketWithFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketPercentageFeeResponse
 */
export const UpdateMarketPercentageFeeResponse = new UpdateMarketPercentageFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketFixedFeeRequest$Type extends MessageType<UpdateMarketFixedFeeRequest> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketFixedFeeRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "fixed", kind: "message", T: () => Fixed }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketFixedFeeRequest>): UpdateMarketFixedFeeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketFixedFeeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketFixedFeeRequest): UpdateMarketFixedFeeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Fixed fixed */ 2:
                    message.fixed = Fixed.internalBinaryRead(reader, reader.uint32(), options, message.fixed);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketFixedFeeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Fixed fixed = 2; */
        if (message.fixed)
            Fixed.internalBinaryWrite(message.fixed, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketFixedFeeRequest
 */
export const UpdateMarketFixedFeeRequest = new UpdateMarketFixedFeeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketFixedFeeResponse$Type extends MessageType<UpdateMarketFixedFeeResponse> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketFixedFeeResponse", [
            { no: 1, name: "market_with_fee", kind: "message", T: () => MarketWithFee }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketFixedFeeResponse>): UpdateMarketFixedFeeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketFixedFeeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketFixedFeeResponse): UpdateMarketFixedFeeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.MarketWithFee market_with_fee */ 1:
                    message.marketWithFee = MarketWithFee.internalBinaryRead(reader, reader.uint32(), options, message.marketWithFee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketFixedFeeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.MarketWithFee market_with_fee = 1; */
        if (message.marketWithFee)
            MarketWithFee.internalBinaryWrite(message.marketWithFee, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketFixedFeeResponse
 */
export const UpdateMarketFixedFeeResponse = new UpdateMarketFixedFeeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPriceRequest$Type extends MessageType<UpdateMarketPriceRequest> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketPriceRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "price", kind: "message", T: () => Price }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketPriceRequest>): UpdateMarketPriceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPriceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPriceRequest): UpdateMarketPriceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex.v1.Price price */ 2:
                    message.price = Price.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketPriceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex.v1.Price price = 2; */
        if (message.price)
            Price.internalBinaryWrite(message.price, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketPriceRequest
 */
export const UpdateMarketPriceRequest = new UpdateMarketPriceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketPriceResponse$Type extends MessageType<UpdateMarketPriceResponse> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketPriceResponse", []);
    }
    create(value?: PartialMessage<UpdateMarketPriceResponse>): UpdateMarketPriceResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketPriceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketPriceResponse): UpdateMarketPriceResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateMarketPriceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketPriceResponse
 */
export const UpdateMarketPriceResponse = new UpdateMarketPriceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketStrategyRequest$Type extends MessageType<UpdateMarketStrategyRequest> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketStrategyRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "strategy_type", kind: "enum", T: () => ["tdex_daemon.v2.StrategyType", StrategyType] },
            { no: 3, name: "metadata", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateMarketStrategyRequest>): UpdateMarketStrategyRequest {
        const message = { strategyType: 0, metadata: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketStrategyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketStrategyRequest): UpdateMarketStrategyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v2.StrategyType strategy_type */ 2:
                    message.strategyType = reader.int32();
                    break;
                case /* string metadata */ 3:
                    message.metadata = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateMarketStrategyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.StrategyType strategy_type = 2; */
        if (message.strategyType !== 0)
            writer.tag(2, WireType.Varint).int32(message.strategyType);
        /* string metadata = 3; */
        if (message.metadata !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.metadata);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketStrategyRequest
 */
export const UpdateMarketStrategyRequest = new UpdateMarketStrategyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateMarketStrategyResponse$Type extends MessageType<UpdateMarketStrategyResponse> {
    constructor() {
        super("tdex_daemon.v2.UpdateMarketStrategyResponse", []);
    }
    create(value?: PartialMessage<UpdateMarketStrategyResponse>): UpdateMarketStrategyResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateMarketStrategyResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateMarketStrategyResponse): UpdateMarketStrategyResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: UpdateMarketStrategyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.UpdateMarketStrategyResponse
 */
export const UpdateMarketStrategyResponse = new UpdateMarketStrategyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveFeeFragmenterAddressesRequest$Type extends MessageType<DeriveFeeFragmenterAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.DeriveFeeFragmenterAddressesRequest", [
            { no: 1, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveFeeFragmenterAddressesRequest>): DeriveFeeFragmenterAddressesRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveFeeFragmenterAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveFeeFragmenterAddressesRequest): DeriveFeeFragmenterAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_of_addresses = 1 [jstype = JS_NUMBER];*/ 1:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveFeeFragmenterAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_of_addresses = 1 [jstype = JS_NUMBER]; */
        if (message.numOfAddresses !== 0)
            writer.tag(1, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveFeeFragmenterAddressesRequest
 */
export const DeriveFeeFragmenterAddressesRequest = new DeriveFeeFragmenterAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveFeeFragmenterAddressesResponse$Type extends MessageType<DeriveFeeFragmenterAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.DeriveFeeFragmenterAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveFeeFragmenterAddressesResponse>): DeriveFeeFragmenterAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveFeeFragmenterAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveFeeFragmenterAddressesResponse): DeriveFeeFragmenterAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveFeeFragmenterAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveFeeFragmenterAddressesResponse
 */
export const DeriveFeeFragmenterAddressesResponse = new DeriveFeeFragmenterAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeFragmenterAddressesRequest$Type extends MessageType<ListFeeFragmenterAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.ListFeeFragmenterAddressesRequest", []);
    }
    create(value?: PartialMessage<ListFeeFragmenterAddressesRequest>): ListFeeFragmenterAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeFragmenterAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeFragmenterAddressesRequest): ListFeeFragmenterAddressesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListFeeFragmenterAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListFeeFragmenterAddressesRequest
 */
export const ListFeeFragmenterAddressesRequest = new ListFeeFragmenterAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListFeeFragmenterAddressesResponse$Type extends MessageType<ListFeeFragmenterAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.ListFeeFragmenterAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListFeeFragmenterAddressesResponse>): ListFeeFragmenterAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListFeeFragmenterAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListFeeFragmenterAddressesResponse): ListFeeFragmenterAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListFeeFragmenterAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListFeeFragmenterAddressesResponse
 */
export const ListFeeFragmenterAddressesResponse = new ListFeeFragmenterAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeFragmenterBalanceRequest$Type extends MessageType<GetFeeFragmenterBalanceRequest> {
    constructor() {
        super("tdex_daemon.v2.GetFeeFragmenterBalanceRequest", []);
    }
    create(value?: PartialMessage<GetFeeFragmenterBalanceRequest>): GetFeeFragmenterBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeFragmenterBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeFragmenterBalanceRequest): GetFeeFragmenterBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFeeFragmenterBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetFeeFragmenterBalanceRequest
 */
export const GetFeeFragmenterBalanceRequest = new GetFeeFragmenterBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFeeFragmenterBalanceResponse$Type extends MessageType<GetFeeFragmenterBalanceResponse> {
    constructor() {
        super("tdex_daemon.v2.GetFeeFragmenterBalanceResponse", [
            { no: 1, name: "balance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Balance } }
        ]);
    }
    create(value?: PartialMessage<GetFeeFragmenterBalanceResponse>): GetFeeFragmenterBalanceResponse {
        const message = { balance: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFeeFragmenterBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFeeFragmenterBalanceResponse): GetFeeFragmenterBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, tdex_daemon.v2.Balance> balance */ 1:
                    this.binaryReadMap1(message.balance, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetFeeFragmenterBalanceResponse["balance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetFeeFragmenterBalanceResponse["balance"] | undefined, val: GetFeeFragmenterBalanceResponse["balance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Balance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v2.GetFeeFragmenterBalanceResponse.balance");
            }
        }
        map[key ?? ""] = val ?? Balance.create();
    }
    internalBinaryWrite(message: GetFeeFragmenterBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, tdex_daemon.v2.Balance> balance = 1; */
        for (let k of Object.keys(message.balance)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Balance.internalBinaryWrite(message.balance[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetFeeFragmenterBalanceResponse
 */
export const GetFeeFragmenterBalanceResponse = new GetFeeFragmenterBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeFragmenterSplitFundsRequest$Type extends MessageType<FeeFragmenterSplitFundsRequest> {
    constructor() {
        super("tdex_daemon.v2.FeeFragmenterSplitFundsRequest", [
            { no: 1, name: "max_fragments", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<FeeFragmenterSplitFundsRequest>): FeeFragmenterSplitFundsRequest {
        const message = { maxFragments: 0, millisatsPerByte: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeFragmenterSplitFundsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeFragmenterSplitFundsRequest): FeeFragmenterSplitFundsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 max_fragments */ 1:
                    message.maxFragments = reader.uint32();
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeFragmenterSplitFundsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 max_fragments = 1; */
        if (message.maxFragments !== 0)
            writer.tag(1, WireType.Varint).uint32(message.maxFragments);
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.FeeFragmenterSplitFundsRequest
 */
export const FeeFragmenterSplitFundsRequest = new FeeFragmenterSplitFundsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FeeFragmenterSplitFundsResponse$Type extends MessageType<FeeFragmenterSplitFundsResponse> {
    constructor() {
        super("tdex_daemon.v2.FeeFragmenterSplitFundsResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FeeFragmenterSplitFundsResponse>): FeeFragmenterSplitFundsResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FeeFragmenterSplitFundsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FeeFragmenterSplitFundsResponse): FeeFragmenterSplitFundsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FeeFragmenterSplitFundsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.FeeFragmenterSplitFundsResponse
 */
export const FeeFragmenterSplitFundsResponse = new FeeFragmenterSplitFundsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeFragmenterRequest$Type extends MessageType<WithdrawFeeFragmenterRequest> {
    constructor() {
        super("tdex_daemon.v2.WithdrawFeeFragmenterRequest", [
            { no: 1, name: "outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TxOutput },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeFragmenterRequest>): WithdrawFeeFragmenterRequest {
        const message = { outputs: [], millisatsPerByte: 0, password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeFragmenterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeFragmenterRequest): WithdrawFeeFragmenterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.TxOutput outputs */ 1:
                    message.outputs.push(TxOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeFragmenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.TxOutput outputs = 1; */
        for (let i = 0; i < message.outputs.length; i++)
            TxOutput.internalBinaryWrite(message.outputs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawFeeFragmenterRequest
 */
export const WithdrawFeeFragmenterRequest = new WithdrawFeeFragmenterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawFeeFragmenterResponse$Type extends MessageType<WithdrawFeeFragmenterResponse> {
    constructor() {
        super("tdex_daemon.v2.WithdrawFeeFragmenterResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawFeeFragmenterResponse>): WithdrawFeeFragmenterResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawFeeFragmenterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawFeeFragmenterResponse): WithdrawFeeFragmenterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawFeeFragmenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawFeeFragmenterResponse
 */
export const WithdrawFeeFragmenterResponse = new WithdrawFeeFragmenterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveMarketFragmenterAddressesRequest$Type extends MessageType<DeriveMarketFragmenterAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.DeriveMarketFragmenterAddressesRequest", [
            { no: 1, name: "num_of_addresses", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveMarketFragmenterAddressesRequest>): DeriveMarketFragmenterAddressesRequest {
        const message = { numOfAddresses: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveMarketFragmenterAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveMarketFragmenterAddressesRequest): DeriveMarketFragmenterAddressesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 num_of_addresses = 1 [jstype = JS_NUMBER];*/ 1:
                    message.numOfAddresses = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveMarketFragmenterAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 num_of_addresses = 1 [jstype = JS_NUMBER]; */
        if (message.numOfAddresses !== 0)
            writer.tag(1, WireType.Varint).int64(message.numOfAddresses);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveMarketFragmenterAddressesRequest
 */
export const DeriveMarketFragmenterAddressesRequest = new DeriveMarketFragmenterAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeriveMarketFragmenterAddressesResponse$Type extends MessageType<DeriveMarketFragmenterAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.DeriveMarketFragmenterAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeriveMarketFragmenterAddressesResponse>): DeriveMarketFragmenterAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeriveMarketFragmenterAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeriveMarketFragmenterAddressesResponse): DeriveMarketFragmenterAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeriveMarketFragmenterAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.DeriveMarketFragmenterAddressesResponse
 */
export const DeriveMarketFragmenterAddressesResponse = new DeriveMarketFragmenterAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketFragmenterAddressesRequest$Type extends MessageType<ListMarketFragmenterAddressesRequest> {
    constructor() {
        super("tdex_daemon.v2.ListMarketFragmenterAddressesRequest", []);
    }
    create(value?: PartialMessage<ListMarketFragmenterAddressesRequest>): ListMarketFragmenterAddressesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketFragmenterAddressesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketFragmenterAddressesRequest): ListMarketFragmenterAddressesRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListMarketFragmenterAddressesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListMarketFragmenterAddressesRequest
 */
export const ListMarketFragmenterAddressesRequest = new ListMarketFragmenterAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketFragmenterAddressesResponse$Type extends MessageType<ListMarketFragmenterAddressesResponse> {
    constructor() {
        super("tdex_daemon.v2.ListMarketFragmenterAddressesResponse", [
            { no: 1, name: "addresses", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListMarketFragmenterAddressesResponse>): ListMarketFragmenterAddressesResponse {
        const message = { addresses: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketFragmenterAddressesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketFragmenterAddressesResponse): ListMarketFragmenterAddressesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string addresses */ 1:
                    message.addresses.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketFragmenterAddressesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string addresses = 1; */
        for (let i = 0; i < message.addresses.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListMarketFragmenterAddressesResponse
 */
export const ListMarketFragmenterAddressesResponse = new ListMarketFragmenterAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketFragmenterBalanceRequest$Type extends MessageType<GetMarketFragmenterBalanceRequest> {
    constructor() {
        super("tdex_daemon.v2.GetMarketFragmenterBalanceRequest", []);
    }
    create(value?: PartialMessage<GetMarketFragmenterBalanceRequest>): GetMarketFragmenterBalanceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketFragmenterBalanceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketFragmenterBalanceRequest): GetMarketFragmenterBalanceRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMarketFragmenterBalanceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetMarketFragmenterBalanceRequest
 */
export const GetMarketFragmenterBalanceRequest = new GetMarketFragmenterBalanceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMarketFragmenterBalanceResponse$Type extends MessageType<GetMarketFragmenterBalanceResponse> {
    constructor() {
        super("tdex_daemon.v2.GetMarketFragmenterBalanceResponse", [
            { no: 1, name: "balance", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Balance } }
        ]);
    }
    create(value?: PartialMessage<GetMarketFragmenterBalanceResponse>): GetMarketFragmenterBalanceResponse {
        const message = { balance: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMarketFragmenterBalanceResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMarketFragmenterBalanceResponse): GetMarketFragmenterBalanceResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, tdex_daemon.v2.Balance> balance */ 1:
                    this.binaryReadMap1(message.balance, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: GetMarketFragmenterBalanceResponse["balance"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof GetMarketFragmenterBalanceResponse["balance"] | undefined, val: GetMarketFragmenterBalanceResponse["balance"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Balance.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field tdex_daemon.v2.GetMarketFragmenterBalanceResponse.balance");
            }
        }
        map[key ?? ""] = val ?? Balance.create();
    }
    internalBinaryWrite(message: GetMarketFragmenterBalanceResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, tdex_daemon.v2.Balance> balance = 1; */
        for (let k of Object.keys(message.balance)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Balance.internalBinaryWrite(message.balance[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.GetMarketFragmenterBalanceResponse
 */
export const GetMarketFragmenterBalanceResponse = new GetMarketFragmenterBalanceResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketFragmenterSplitFundsRequest$Type extends MessageType<MarketFragmenterSplitFundsRequest> {
    constructor() {
        super("tdex_daemon.v2.MarketFragmenterSplitFundsRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<MarketFragmenterSplitFundsRequest>): MarketFragmenterSplitFundsRequest {
        const message = { millisatsPerByte: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketFragmenterSplitFundsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketFragmenterSplitFundsRequest): MarketFragmenterSplitFundsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketFragmenterSplitFundsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.MarketFragmenterSplitFundsRequest
 */
export const MarketFragmenterSplitFundsRequest = new MarketFragmenterSplitFundsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MarketFragmenterSplitFundsResponse$Type extends MessageType<MarketFragmenterSplitFundsResponse> {
    constructor() {
        super("tdex_daemon.v2.MarketFragmenterSplitFundsResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MarketFragmenterSplitFundsResponse>): MarketFragmenterSplitFundsResponse {
        const message = { message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MarketFragmenterSplitFundsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MarketFragmenterSplitFundsResponse): MarketFragmenterSplitFundsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MarketFragmenterSplitFundsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.MarketFragmenterSplitFundsResponse
 */
export const MarketFragmenterSplitFundsResponse = new MarketFragmenterSplitFundsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketFragmenterRequest$Type extends MessageType<WithdrawMarketFragmenterRequest> {
    constructor() {
        super("tdex_daemon.v2.WithdrawMarketFragmenterRequest", [
            { no: 1, name: "outputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TxOutput },
            { no: 2, name: "millisats_per_byte", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "password", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketFragmenterRequest>): WithdrawMarketFragmenterRequest {
        const message = { outputs: [], millisatsPerByte: 0, password: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketFragmenterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketFragmenterRequest): WithdrawMarketFragmenterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.TxOutput outputs */ 1:
                    message.outputs.push(TxOutput.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 millisats_per_byte */ 2:
                    message.millisatsPerByte = reader.uint64().toNumber();
                    break;
                case /* string password */ 3:
                    message.password = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketFragmenterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.TxOutput outputs = 1; */
        for (let i = 0; i < message.outputs.length; i++)
            TxOutput.internalBinaryWrite(message.outputs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 millisats_per_byte = 2; */
        if (message.millisatsPerByte !== 0)
            writer.tag(2, WireType.Varint).uint64(message.millisatsPerByte);
        /* string password = 3; */
        if (message.password !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.password);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawMarketFragmenterRequest
 */
export const WithdrawMarketFragmenterRequest = new WithdrawMarketFragmenterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawMarketFragmenterResponse$Type extends MessageType<WithdrawMarketFragmenterResponse> {
    constructor() {
        super("tdex_daemon.v2.WithdrawMarketFragmenterResponse", [
            { no: 1, name: "txid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawMarketFragmenterResponse>): WithdrawMarketFragmenterResponse {
        const message = { txid: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawMarketFragmenterResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawMarketFragmenterResponse): WithdrawMarketFragmenterResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string txid */ 1:
                    message.txid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawMarketFragmenterResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string txid = 1; */
        if (message.txid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.txid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.WithdrawMarketFragmenterResponse
 */
export const WithdrawMarketFragmenterResponse = new WithdrawMarketFragmenterResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketsRequest$Type extends MessageType<ListMarketsRequest> {
    constructor() {
        super("tdex_daemon.v2.ListMarketsRequest", []);
    }
    create(value?: PartialMessage<ListMarketsRequest>): ListMarketsRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketsRequest): ListMarketsRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ListMarketsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListMarketsRequest
 */
export const ListMarketsRequest = new ListMarketsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListMarketsResponse$Type extends MessageType<ListMarketsResponse> {
    constructor() {
        super("tdex_daemon.v2.ListMarketsResponse", [
            { no: 1, name: "markets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MarketInfo }
        ]);
    }
    create(value?: PartialMessage<ListMarketsResponse>): ListMarketsResponse {
        const message = { markets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListMarketsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListMarketsResponse): ListMarketsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.MarketInfo markets */ 1:
                    message.markets.push(MarketInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListMarketsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.MarketInfo markets = 1; */
        for (let i = 0; i < message.markets.length; i++)
            MarketInfo.internalBinaryWrite(message.markets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListMarketsResponse
 */
export const ListMarketsResponse = new ListMarketsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTradesRequest$Type extends MessageType<ListTradesRequest> {
    constructor() {
        super("tdex_daemon.v2.ListTradesRequest", [
            { no: 1, name: "market", kind: "message", T: () => Market },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListTradesRequest>): ListTradesRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListTradesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTradesRequest): ListTradesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex.v1.Market market */ 1:
                    message.market = Market.internalBinaryRead(reader, reader.uint32(), options, message.market);
                    break;
                case /* tdex_daemon.v2.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTradesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex.v1.Market market = 1; */
        if (message.market)
            Market.internalBinaryWrite(message.market, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tdex_daemon.v2.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListTradesRequest
 */
export const ListTradesRequest = new ListTradesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListTradesResponse$Type extends MessageType<ListTradesResponse> {
    constructor() {
        super("tdex_daemon.v2.ListTradesResponse", [
            { no: 1, name: "trades", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => TradeInfo }
        ]);
    }
    create(value?: PartialMessage<ListTradesResponse>): ListTradesResponse {
        const message = { trades: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListTradesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListTradesResponse): ListTradesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.TradeInfo trades */ 1:
                    message.trades.push(TradeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListTradesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.TradeInfo trades = 1; */
        for (let i = 0; i < message.trades.length; i++)
            TradeInfo.internalBinaryWrite(message.trades[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListTradesResponse
 */
export const ListTradesResponse = new ListTradesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUtxosRequest$Type extends MessageType<ListUtxosRequest> {
    constructor() {
        super("tdex_daemon.v2.ListUtxosRequest", [
            { no: 1, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListUtxosRequest>): ListUtxosRequest {
        const message = { accountName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUtxosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUtxosRequest): ListUtxosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* tdex_daemon.v2.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUtxosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 1; */
        if (message.accountName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* tdex_daemon.v2.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListUtxosRequest
 */
export const ListUtxosRequest = new ListUtxosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListUtxosResponse$Type extends MessageType<ListUtxosResponse> {
    constructor() {
        super("tdex_daemon.v2.ListUtxosResponse", [
            { no: 1, name: "spendable_utxos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoInfo },
            { no: 2, name: "locked_utxos", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UtxoInfo }
        ]);
    }
    create(value?: PartialMessage<ListUtxosResponse>): ListUtxosResponse {
        const message = { spendableUtxos: [], lockedUtxos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListUtxosResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListUtxosResponse): ListUtxosResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.UtxoInfo spendable_utxos */ 1:
                    message.spendableUtxos.push(UtxoInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tdex_daemon.v2.UtxoInfo locked_utxos */ 2:
                    message.lockedUtxos.push(UtxoInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListUtxosResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.UtxoInfo spendable_utxos = 1; */
        for (let i = 0; i < message.spendableUtxos.length; i++)
            UtxoInfo.internalBinaryWrite(message.spendableUtxos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tdex_daemon.v2.UtxoInfo locked_utxos = 2; */
        for (let i = 0; i < message.lockedUtxos.length; i++)
            UtxoInfo.internalBinaryWrite(message.lockedUtxos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListUtxosResponse
 */
export const ListUtxosResponse = new ListUtxosResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddWebhookRequest$Type extends MessageType<AddWebhookRequest> {
    constructor() {
        super("tdex_daemon.v2.AddWebhookRequest", [
            { no: 1, name: "endpoint", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "action", kind: "enum", T: () => ["tdex_daemon.v2.ActionType", ActionType] },
            { no: 3, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddWebhookRequest>): AddWebhookRequest {
        const message = { endpoint: "", action: 0, secret: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddWebhookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddWebhookRequest): AddWebhookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string endpoint */ 1:
                    message.endpoint = reader.string();
                    break;
                case /* tdex_daemon.v2.ActionType action */ 2:
                    message.action = reader.int32();
                    break;
                case /* string secret */ 3:
                    message.secret = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddWebhookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string endpoint = 1; */
        if (message.endpoint !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.endpoint);
        /* tdex_daemon.v2.ActionType action = 2; */
        if (message.action !== 0)
            writer.tag(2, WireType.Varint).int32(message.action);
        /* string secret = 3; */
        if (message.secret !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.secret);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.AddWebhookRequest
 */
export const AddWebhookRequest = new AddWebhookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddWebhookResponse$Type extends MessageType<AddWebhookResponse> {
    constructor() {
        super("tdex_daemon.v2.AddWebhookResponse", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<AddWebhookResponse>): AddWebhookResponse {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddWebhookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddWebhookResponse): AddWebhookResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddWebhookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.AddWebhookResponse
 */
export const AddWebhookResponse = new AddWebhookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveWebhookRequest$Type extends MessageType<RemoveWebhookRequest> {
    constructor() {
        super("tdex_daemon.v2.RemoveWebhookRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveWebhookRequest>): RemoveWebhookRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveWebhookRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveWebhookRequest): RemoveWebhookRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveWebhookRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.RemoveWebhookRequest
 */
export const RemoveWebhookRequest = new RemoveWebhookRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveWebhookResponse$Type extends MessageType<RemoveWebhookResponse> {
    constructor() {
        super("tdex_daemon.v2.RemoveWebhookResponse", []);
    }
    create(value?: PartialMessage<RemoveWebhookResponse>): RemoveWebhookResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveWebhookResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveWebhookResponse): RemoveWebhookResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RemoveWebhookResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.RemoveWebhookResponse
 */
export const RemoveWebhookResponse = new RemoveWebhookResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWebhooksRequest$Type extends MessageType<ListWebhooksRequest> {
    constructor() {
        super("tdex_daemon.v2.ListWebhooksRequest", [
            { no: 1, name: "action", kind: "enum", T: () => ["tdex_daemon.v2.ActionType", ActionType] }
        ]);
    }
    create(value?: PartialMessage<ListWebhooksRequest>): ListWebhooksRequest {
        const message = { action: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWebhooksRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWebhooksRequest): ListWebhooksRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tdex_daemon.v2.ActionType action */ 1:
                    message.action = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWebhooksRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tdex_daemon.v2.ActionType action = 1; */
        if (message.action !== 0)
            writer.tag(1, WireType.Varint).int32(message.action);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListWebhooksRequest
 */
export const ListWebhooksRequest = new ListWebhooksRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWebhooksResponse$Type extends MessageType<ListWebhooksResponse> {
    constructor() {
        super("tdex_daemon.v2.ListWebhooksResponse", [
            { no: 1, name: "webhook_info", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WebhookInfo }
        ]);
    }
    create(value?: PartialMessage<ListWebhooksResponse>): ListWebhooksResponse {
        const message = { webhookInfo: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWebhooksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWebhooksResponse): ListWebhooksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tdex_daemon.v2.WebhookInfo webhook_info */ 1:
                    message.webhookInfo.push(WebhookInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWebhooksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tdex_daemon.v2.WebhookInfo webhook_info = 1; */
        for (let i = 0; i < message.webhookInfo.length; i++)
            WebhookInfo.internalBinaryWrite(message.webhookInfo[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListWebhooksResponse
 */
export const ListWebhooksResponse = new ListWebhooksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDepositsRequest$Type extends MessageType<ListDepositsRequest> {
    constructor() {
        super("tdex_daemon.v2.ListDepositsRequest", [
            { no: 1, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListDepositsRequest>): ListDepositsRequest {
        const message = { accountName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDepositsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDepositsRequest): ListDepositsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* tdex_daemon.v2.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDepositsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 1; */
        if (message.accountName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* tdex_daemon.v2.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListDepositsRequest
 */
export const ListDepositsRequest = new ListDepositsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDepositsResponse$Type extends MessageType<ListDepositsResponse> {
    constructor() {
        super("tdex_daemon.v2.ListDepositsResponse", [
            { no: 1, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "deposits", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<ListDepositsResponse>): ListDepositsResponse {
        const message = { accountName: "", deposits: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDepositsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDepositsResponse): ListDepositsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* repeated tdex_daemon.v2.Transaction deposits */ 2:
                    message.deposits.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDepositsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 1; */
        if (message.accountName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* repeated tdex_daemon.v2.Transaction deposits = 2; */
        for (let i = 0; i < message.deposits.length; i++)
            Transaction.internalBinaryWrite(message.deposits[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListDepositsResponse
 */
export const ListDepositsResponse = new ListDepositsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWithdrawalsRequest$Type extends MessageType<ListWithdrawalsRequest> {
    constructor() {
        super("tdex_daemon.v2.ListWithdrawalsRequest", [
            { no: 1, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "page", kind: "message", T: () => Page }
        ]);
    }
    create(value?: PartialMessage<ListWithdrawalsRequest>): ListWithdrawalsRequest {
        const message = { accountName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWithdrawalsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWithdrawalsRequest): ListWithdrawalsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* tdex_daemon.v2.Page page */ 2:
                    message.page = Page.internalBinaryRead(reader, reader.uint32(), options, message.page);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWithdrawalsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 1; */
        if (message.accountName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* tdex_daemon.v2.Page page = 2; */
        if (message.page)
            Page.internalBinaryWrite(message.page, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListWithdrawalsRequest
 */
export const ListWithdrawalsRequest = new ListWithdrawalsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListWithdrawalsResponse$Type extends MessageType<ListWithdrawalsResponse> {
    constructor() {
        super("tdex_daemon.v2.ListWithdrawalsResponse", [
            { no: 1, name: "account_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "withdrawals", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<ListWithdrawalsResponse>): ListWithdrawalsResponse {
        const message = { accountName: "", withdrawals: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListWithdrawalsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListWithdrawalsResponse): ListWithdrawalsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_name */ 1:
                    message.accountName = reader.string();
                    break;
                case /* repeated tdex_daemon.v2.Transaction withdrawals */ 2:
                    message.withdrawals.push(Transaction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListWithdrawalsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_name = 1; */
        if (message.accountName !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountName);
        /* repeated tdex_daemon.v2.Transaction withdrawals = 2; */
        for (let i = 0; i < message.withdrawals.length; i++)
            Transaction.internalBinaryWrite(message.withdrawals[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tdex_daemon.v2.ListWithdrawalsResponse
 */
export const ListWithdrawalsResponse = new ListWithdrawalsResponse$Type();
/**
 * @generated ServiceType for protobuf service tdex_daemon.v2.OperatorService
 */
export const OperatorService = new ServiceType("tdex_daemon.v2.OperatorService", [
    { name: "DeriveFeeAddresses", options: {}, I: DeriveFeeAddressesRequest, O: DeriveFeeAddressesResponse },
    { name: "ListFeeAddresses", options: {}, I: ListFeeAddressesRequest, O: ListFeeAddressesResponse },
    { name: "GetFeeBalance", options: {}, I: GetFeeBalanceRequest, O: GetFeeBalanceResponse },
    { name: "WithdrawFee", options: {}, I: WithdrawFeeRequest, O: WithdrawFeeResponse },
    { name: "NewMarket", options: {}, I: NewMarketRequest, O: NewMarketResponse },
    { name: "GetMarketInfo", options: {}, I: GetMarketInfoRequest, O: GetMarketInfoResponse },
    { name: "DeriveMarketAddresses", options: {}, I: DeriveMarketAddressesRequest, O: DeriveMarketAddressesResponse },
    { name: "ListMarketAddresses", options: {}, I: ListMarketAddressesRequest, O: ListMarketAddressesResponse },
    { name: "OpenMarket", options: {}, I: OpenMarketRequest, O: OpenMarketResponse },
    { name: "CloseMarket", options: {}, I: CloseMarketRequest, O: CloseMarketResponse },
    { name: "DropMarket", options: {}, I: DropMarketRequest, O: DropMarketResponse },
    { name: "WithdrawMarket", options: {}, I: WithdrawMarketRequest, O: WithdrawMarketResponse },
    { name: "GetMarketReport", options: {}, I: GetMarketReportRequest, O: GetMarketReportResponse },
    { name: "UpdateMarketPercentageFee", options: {}, I: UpdateMarketPercentageFeeRequest, O: UpdateMarketPercentageFeeResponse },
    { name: "UpdateMarketFixedFee", options: {}, I: UpdateMarketFixedFeeRequest, O: UpdateMarketFixedFeeResponse },
    { name: "UpdateMarketPrice", options: {}, I: UpdateMarketPriceRequest, O: UpdateMarketPriceResponse },
    { name: "UpdateMarketStrategy", options: {}, I: UpdateMarketStrategyRequest, O: UpdateMarketStrategyResponse },
    { name: "DeriveFeeFragmenterAddresses", options: {}, I: DeriveFeeFragmenterAddressesRequest, O: DeriveFeeFragmenterAddressesResponse },
    { name: "ListFeeFragmenterAddresses", options: {}, I: ListFeeFragmenterAddressesRequest, O: ListFeeFragmenterAddressesResponse },
    { name: "GetFeeFragmenterBalance", options: {}, I: GetFeeFragmenterBalanceRequest, O: GetFeeFragmenterBalanceResponse },
    { name: "FeeFragmenterSplitFunds", serverStreaming: true, options: {}, I: FeeFragmenterSplitFundsRequest, O: FeeFragmenterSplitFundsResponse },
    { name: "WithdrawFeeFragmenter", options: {}, I: WithdrawFeeFragmenterRequest, O: WithdrawFeeFragmenterResponse },
    { name: "DeriveMarketFragmenterAddresses", options: {}, I: DeriveMarketFragmenterAddressesRequest, O: DeriveMarketFragmenterAddressesResponse },
    { name: "ListMarketFragmenterAddresses", options: {}, I: ListMarketFragmenterAddressesRequest, O: ListMarketFragmenterAddressesResponse },
    { name: "GetMarketFragmenterBalance", options: {}, I: GetMarketFragmenterBalanceRequest, O: GetMarketFragmenterBalanceResponse },
    { name: "MarketFragmenterSplitFunds", serverStreaming: true, options: {}, I: MarketFragmenterSplitFundsRequest, O: MarketFragmenterSplitFundsResponse },
    { name: "WithdrawMarketFragmenter", options: {}, I: WithdrawMarketFragmenterRequest, O: WithdrawMarketFragmenterResponse },
    { name: "ListMarkets", options: {}, I: ListMarketsRequest, O: ListMarketsResponse },
    { name: "ListTrades", options: {}, I: ListTradesRequest, O: ListTradesResponse },
    { name: "ListUtxos", options: {}, I: ListUtxosRequest, O: ListUtxosResponse },
    { name: "AddWebhook", options: {}, I: AddWebhookRequest, O: AddWebhookResponse },
    { name: "RemoveWebhook", options: {}, I: RemoveWebhookRequest, O: RemoveWebhookResponse },
    { name: "ListWebhooks", options: {}, I: ListWebhooksRequest, O: ListWebhooksResponse },
    { name: "ListDeposits", options: {}, I: ListDepositsRequest, O: ListDepositsResponse },
    { name: "ListWithdrawals", options: {}, I: ListWithdrawalsRequest, O: ListWithdrawalsResponse }
]);
